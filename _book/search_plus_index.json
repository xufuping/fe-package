{"./":{"url":"./","title":"写在前面","keywords":"","body":"写在前面 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 14:16:32 "},"part1/writing.html":{"url":"part1/writing.html","title":"Writing is nice","keywords":"","body":"第一部分 写作 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 13:43:54 "},"part1/gitbook.html":{"url":"part1/gitbook.html","title":"GitBook is nice","keywords":"","body":"第一部分 小书 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 13:44:08 "},"part2/feedback_please.html":{"url":"part2/feedback_please.html","title":"We love feedback","keywords":"","body":"第二部分 流 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 13:44:39 "},"part2/better_tools.html":{"url":"part2/better_tools.html","title":"Better tools for authors","keywords":"","body":"第一部分 小工具 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 13:44:53 "},"part3/javascript_high_level/1.html":{"url":"part3/javascript_high_level/1.html","title":"1.简介","keywords":"","body":"1.JavaScript 简介 1.1 JS 实现 一个完整的 JS 实现应该由下列三个不同的部分组成：==核心(ECMAScript)==、==文档对象模型(DOM)==、==浏览器对象模型(BOM)==. 1.1.1 核心(ECMAScript) ECMAScript，由 ECMA-262 定义，提供核心语言功能。 ECMAScript 与 Web 浏览器没有依赖关系，Web 浏览器只是 ECMAScript 可能的宿主环境之一。 1.1.2 文档对象模型(DOM) DOM 主要负责提供访问和操作网页内容的方法和接口。 DOM 把整个页面映射为一个多层节点结构(表示文档的树形图)，借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。 1.1.2.1 DOM 级别 1.1.2.1.1 DOM1 级别： DOM1 级别由两个模块组成：DOM 核心和 DOM HTML. DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。 DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。 1.1.2.1.2 DOM2 级别： DOM2 在 DOM 的基础上又扩充了(DHTML 一直都支持的)鼠标和用户界面事件、范围、遍历(迭代 DOM 文档的方法)等细分模块，而且通过对象接口增加了对 CSS 的支持。 DOM2 级引入了下列新模块，也给出了众多新类型和新接口的定义： DOM视图：定义了跟踪不同文档（例如，应用CSS之前和之后的文档）视图的接口； DOM事件：定义了事件和事件处理的接口； DOM样式：定义了基于CSS为元素应用样式的接口； DOM遍历和范围：定义了遍历和操作文档树的接口。 1.1.2.1.3 DOM3 级别： 进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存模块中定义；新增了验证文档的方法——在 DOM 验证模块中定义。同时扩展了 DOM 核心，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base. （DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM。） 1.1.3 浏览器对象模型(BOM) BOM 提供与浏览器交互的方法和接口，可以访问和操作浏览器窗口。 从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分，下面就是一些扩展： 弹出新浏览器窗口的功能； 移动、缩放、关闭浏览器窗口的功能； 提供浏览器详细信息的navigator对象； 提供浏览器所加载页面的详细信息的location对象； 提供用户显示器分辨率详细信息的screen对象； 对cookies的支持； 像XMLHttpRequest和IE 的 ActiveXObject 这样的自定义对象。 （HTML5 致力于把很多 BOM 功能写入正式规范） 2.在 HTML 中使用 JavaScript 2.1 元素 六个属性 async 【异步脚本】可选。表示立即下载脚本，只对外部脚本文件有效。(标记为async的脚本并不保证按照指定它们的先后顺序执行。) //使用：直接写入async，在XHTML文档中写入 async=\"async\" charset 可选。表示通过src指定的代码的字符集。（被大多数浏览器忽略，少有人用） defer 【延迟脚本】可选。表示脚本延迟到文档完全被解析和显示之后再执行(但不影响下载次序)。只对外部脚本文件有效。 // 使用：直接写入 defer=\"defer\" language 已废弃。 src 可选。导入外部脚本文件。 type 可选。表示编写代码用的脚本语言的内容类型(MIME类型)，一般值为\"text/javascript\". // 只要不出现defer和async属性，浏览器都会按照元素在页面中出现的先后顺序对它们依次进行解析。 2.1.1 标签的位置 放在，必须等到全部 JavaScript 代码被下载解析执行后才能开始呈现页面的内容。这很有可能导致浏览器在呈现页面时出现明显的延迟，造成不好的用户体验。 所以，为了避免这个问题，现代 Web 应用程序一般把 JavaScript 引用放在元素中，放在页面的内容后面，加强用户体验。 2.1.2 XHTML 严格模式 XHTML 结合了 XML 部分的强大功能以及 HTML 大多数的简单特性，XHTML 要求更加严谨，相对 HTML 的几大区别： XHTML 要求争取额嵌套； XHTML 所有元素必须关闭； XHTML 区分大小写； XHTML 属性值要用双引号； XHTML 用id属性代替name属性； XHTML 特殊字符的处理。 2.2 嵌入代码与外部文件 外部 JS 的优势： 可维护性：专注编辑JS 可缓存：同代码多样使用 适应未来：外部JS无序使用XHTML或注释hack，HTML和XHTML包含外部文件的语法是相同的。 2.3 文档模式 最初的两种文档模式：混杂模式和标准模式。 所有浏览器会默认开启混杂模式，不同浏览器在这种模式下行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。 开启标准模式： 触发标准模式: 触发准标准模式: 2.4 元素 浏览器不支持脚本或者脚本被禁用，才会触发. noscript 本页面JavaScript脚本被禁用 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:00:56 "},"part3/javascript_high_level/2.html":{"url":"part3/javascript_high_level/2.html","title":"2.基本概念","keywords":"","body":"1.语法，关键字和保留字，变量 1.1语法 1.ECMAScript区分大小写； 2.标识符(变量、函数、属性的名字或者函数参数)：第一个字符必须是字母、下划线或一个美元符号($)，其他字符可以是字母、下划线、美元符号或数字(建议采用驼峰命名)； 3.严格模式：为JS定义了一种不同额度解析与执行模型，对ES3的一些不确定行为进行处理，对某些不安全操作也会抛出错误。启用严格模式，在脚本顶部添加代码：\"use strict\"。 4.语句：分号结尾，使用代码快写法在流控制语句等语句中使用{} 1.2关键字和保留字 不要使用关键字和保留字作为标识符和属性名，以便与将来的ECMAScript版本兼容。常见的有： 关键字: break,do,typeof,case,else,new,var continue,for,switch,while,function this,with,default,if,throw,delete,try 保留字: abstract,int,short,boolean,export static,byte,long,super,char,final class,float,throws,const,goto,private debugger,protected,double,import,public 1.3变量 ES变量是松散类型的，可以保存任何类型的数据。 var message = \"hi\"; 2.数据类型 2.1 typeof操作符 作用：检测给定变量的数据类型： 值未定义——\"undefined\" 值是布尔值——\"boolean\" 值是字符串——\"string\" 值是数值——\"number\" 值是对象或null——\"object\"(null被认为是一个空的对象引用) 值是函数——\"function\" 示例： var message = \"some string\"; console.log(typeof message); // \"string\" ▲typeof是一个操作符，不是一个函数。 2.2 Undefined类型 未被初始化和未被声明的对象，都会返回undefined。 var message; //var age; console.log(message); // \"undefined\" console.log(age); // 产生错误 2.3 Null类型 空对象 ▲推荐写法： 如果定义的变量准备将来用于保存对象，可以把变量初始值设为null。 这样没有被声明的变量返回undefined，没有被初始化的变量返回null。 //var message; var age = null; console.log(message); // undefined console.log(age); // null console.log(typeof age); // object 2.4 Boolean类型 true和false区分大小写。下面是Boolean转换： 数据类型 转化为true的值 转换为false的值 Boolean true false String 非空字符串 \"\"（空字符串） Number 非零数字（包括无穷大） 0和NaN Object 任何对象 bull Undefined n/a【不适用】 undefined 对任何数据类型的值调用Boolean()函数，总会返回一个Boolean值。Boolean转换对理解流控制语句很重要，下面是各种数据类型及其对应的转换规则： var message = \"hello!\"; if (message){ alert(\"这是一个非空字符串\"); } else { alert(\"这是一个空字符串\"); } // 这是一个非空字符串，因为message里有字符串。 2.5 Number类型 提示：不要测试特定的浮点数值，它们计算会产生舍入误差，这是基于IEEE754数值的浮点计算的通病； 2.5.1 NaN(非数值，Not a Number) isNaN()函数接受一个参数，确定这个参数是否“不是数值”。 console.log(isNaN(NaN)); // true console.log(isNaN(10)); // false(10是一个数值) console.log(isNaN(\"10\")); // false(数字字符串可以被转换成数值10) console.log(isNaN(\"blue\")); // true(这个字符串不能转换成数值) console.log(isNaN(true)); // false(true可以被转换成数值1) 2.5.2 数值转换 2.5.2.1 Number()用于任何数据类型数值转换 1. 如果是Boolean值，true和false将分别被转换为1和0； 2. 如果是数字值，传入和返回； 3. 如果是null值，返回0 4. 如果是undefined，返回NaN； 5. 如果是字符串： (1). 如果字符串只有数字，权当十进制并转换为十进制，例如“011”转换为“11”，忽略前导0； (2). 如果字符串只有浮点数，转换为浮点数，忽略前导0； (3). 如果有十六进制数转换为相同大小的十进制数值，例如“0xf”转换为“15”； (4). 如果字符串为空，将其转换为0，例如“ \" \" ”转换为“0”； 6. 如果是对象，则调用valueOf()方法，然后按照前面的规则转换返回的值。 如果转换结果为NaN，则调用对象的toString()方法，然后再次按照前面的规则转换返回的字符串值。 示例： var num1 = Number(\"hi\"); var num2 = Number(\" \"); var num3 = Number(\"011\"); var num4 = Number(\"true\"); var num5 = Number(\"undefined\"); var num6 = Number(\"null\"); var num7 = Number(\"0xD\"); console.log(num1,num2,num3,num4,num5,num6,num7); //NaN,0,11,true,NaN,0,13 2.5.2.2 parseInt()用于字符串数值转换为整数 parseInt()可以识别各种整数格式： var num1 = parseInt(\"1234blue\"); var num2 = parseInt(\" \"); var num3 = parseInt(\"0xA\",16); var num4 = parseInt(\"70\",8); // ES5和严格模式不具有解析八进制能力，必须写明基数才行 var num5 = parseInt(\"11\",2); var num6 = parseInt(\"22.5\");// 小数点后面的数字被省略掉 var num7 = parseInt(\"15\"); // 默认十进制转换 console.log(num1,num2,num3,num4,num5,num6,num7); // 1234,NaN,10,56,3,22,15 2.5.2.3 parseFloat()用于字符串数值转换为小数 parseFloat()只解析十进制数值： var num1 = parseFloat(\"1234blue\"); var num2 = parseFloat(\"0xA\"); var num3 = parseFloat(\"22.5\"); var num4 = parseFloat(\"22.34.5\"); var num5 = parseFloat(\"098.5\"); var num6 = parseFloat(\"3.125e7\"); console.log(num1,num2,num3,num4,num5,num6); //1234 0 22.5 22.34 98.5 31250000 2.6 String类型 字符串，建议采用双引号，也可以用单引号。 2.6.1 字符字面量 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\' 单引号 \\\" 双引号 2.6.2 转换为字符串 toString()方法和String()方法: var num = 10; console.log(num.toString()); // \"10\" console.log(num.toString(2)); // \"1010\" console.log(num.toString(8)); // \"12\" console.log(num.toString(16)); // \"a\" var value = true; console.log(value.toString()); // \"true\" var value = null; console.log(value.toString()); // Uncaught TypeError: Cannot read property 'toString' of null null和undefined没有toString()方法，但是String()函数不仅有toString()方法的效用，还可以返回这两个值的字面量。 var value1 = null; var value2 = undefined; console.log(String(value1)); // \"null\" console.log(String(value2)); // \"undefined\" 2.7 Object类型 new操作符创建一个对象 var o = new Object(); Object有下列属性和方法： 1.hasOwnProperty(propertyName)：检查给定的属性是否在当前对象中。 var o = new Object(); o.name = \"xushuai\"; console.log(o.hasOwnProperty(\"name\")); // true 2.isPrototypeof(object):检查传入的对象是否是另一个对象的原型； 3.propertyIsEnumerable(propertyName)：检查给定的属性是否可以用for-in语句； 4.toString():返回对象的字符串表示； 5.valueOf()：返回对象的字符串、数值或布尔值表示，很多时候与toString()方法返回值相同。 3.操作符 【一元操作符（++，--，+，-,+=,-=）、位操作符（~，&，|，^，>,>>>）、乘性操作符（*，/，%）、加性操作符(+,-)、关系操作符（,==）略过】 3.1 布尔操作符 3.1.1 逻辑非(!) 1.如果操作数是一个对象，返回false； 2.如果操作数是一个空字符串，返回true；如果操作数是一个非空字符串，返回false； 3.如果操作数是数值0，返回true；如果操作数是任意非0数值（包括Infinity），返回false; 4.如果操作数是null,NaN,undefined,都返回true。 示例： console.log(!false); // true console.log(!\"\"); // true console.log(!\"blue\"); // false console.log(!0); // true console.log(!12345); // false console.log(!NaN); // true 3.1.2 逻辑与(&&) 1. 如果第一个操作数是对象或者两个操作数都是对象，都返回第二个操作数； 2. 如果有一个操作数是null，返回null; 如果有一个操作数是NaN，返回NaN; 如果有一个操作数是undefined，返回undefined; 如果有一个操作数是false，返回false. 3.1.3 逻辑或(||) 1. 如果第一个操作数是对象或者两个操作数都是对象，返回第一个操作数； 2. 如果第一个操作数的求值结果为false，则返回第二个操作数； 3. 如果有两个操作数是null，返回null; 如果有两个操作数是NaN，返回NaN; 如果有两个操作数是undefined，返回undefined; 如果有一个操作数是true，返回true. 3.2 相等操作符、赋值操作符 3.2.1 相等与不相等 == 和 != ： 1. 如果有一个操作数是布尔值，比较相等性前自动转换为数值，false转换为0，true转换为1； 2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等行之前自动将字符串转换为数值； 3. 如果一个操作数是对象，另一个操作数不是，自动调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较。 示例： null == undefined //true //就是true，记住就好了，哈哈 NaN == NaN //false //非数不等于非数 NaN != NaN //true false == 0;true == 1 //true //false转换后是0，true转换后是1 \"5\" == 5 //true //自动转换字符串为数值 3.2.2 全等与不全等 === 和 !==,▲全等仅限在两个操作数未经转换就相等的情况下返回true，不全等在两个操作数未经转换就不相等的情况下返回true。例如： \"55\" == 55; //true,因为转换后相等 \"55\" === 55; //false,因为不同的数据类型不相等 \"55\" != 55; //false,因为转换后相等 \"55\" !== 55; //true,因为不同的数据类型不相等 null == undefined; //true null === undefined; //false,因为他们是不同类型的值 PS:由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完善性，我们推荐使用全等和不全等操作符。 3.2.3 赋值操作符 var num = 10; var name = \"徐少\"； 3.3 条件操作符、逗号操作符 条件操作符： variable = boolean_expression ? true_value : false_value; 示例： var max = (num1 > num2) ? num1 : num2; //如果num1>num2，返回true，num1赋值给max;否则返回false，num2赋值给max。 逗号操作符： 用逗号操作符声明多个变量，在一条语句中执行多个操作；逗号操作符总是返回表达式中的最后一项。 var num1 = 1,num2 = 2,num3 = 3; //一条语句执行多个操作 var num = (5, 1, 0); //num的值为0 4.流控制语句 4.1 if语句 if (i > 25) { console.log(\"大于25\"); } else if (i 4.2 do-while语句，while语句 do-while语句 do { statement } while (expression); 示例： var i = 0; do { i += 2; } while (i while语句 while (expression) { statement } 示例： var i = 0; while (i 4.3 for语句 for (initialization; expression; post-loop-expression) { statement } 示例： var count = 10; var i = 0; for (; i 4.4 for-in语句 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 for (property in expression){ statement } 示例： for (var propName in window) { document.write(); } //循环显示BOM中window对象的所有属性 如果要迭代的对象的变量值为null或undefined，for-in语句不会执行循环。使用for-in前先检测对象的值不是null或undefined。 4.5 break和continue语句 break跳出整个大循环，continue跳出当次循环后继续执行。 break示例： var num = 0; for (var i=1; i 4.6 switch语句 switch比较值时使用的是全等操作符，因此不会发生类型转换。（例如，\"10\"不等于10） switch (expression) { case value: statement break; case value: statement break; case value: statement break; default: statement } case的含义是：如果表达式等于这个值(value)，则执行后面的语句(statement); break关键字会导致代码执行流跳出switch; 省略break，执行完当前case后，就会继续执行下一个case; default: 表达式不匹配前面任何一种情形的时候，执行这里的代码。 示例： switch (num) { case 1: console.log(\"我是小明\"); break; case 2: console.log(\"我是小红\"); break; case 3: console.log(\"我是小东\"); break; default: console.log(\"你的数字不是1、2、3哟\"); } 4.7 label语句和with语句 label语句可以咋子代码中添加标签，以便将来使用：label:statement start: for(var i=0; i with语句：为了简化多次编写同一个对象的工作。【不建议使用with语句】 5.函数 function functionName(arg0) { statements } ES中任何函数定义时不必指出是否返回值，但后面随时可跟return语句返回值。函数执行完return后停止并立即退出，因此位于return之后的任何代码永远不会执行。 function sum(num1, num2) { return num1 + num2; } var result = sum(5, 10); 建议：要么让函数始终都返回一个值，要么永远都不要返回值，不然时而返回时而不返会给调试代码带来不便。 5.1 参数 (ES参数与其他语言有些不同，不介意传进来多少个或者什么数据类型，比如只传递两个参数，但可以调用任意个参数。)因为：ES中的参数在内部是用一个数组来表示的。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。 通过访问arguments对象的length属性可以获知传递了多少个参数： //开发人员利用这点让函数能够接受任意个参数并分别实现适当功能，这是一个不太完美的重载 function howMany() { console.log(arguments.length); } howMany(11, \"xushao\", abc); // 3 howMany(); // 0 arguments 对象可以与命名参数一起使用： function doAdd(num1, num2) { if(arguments.length == 1) { console.log(num1 + 10); } else if (arguments.length == 2) { console.log(arguments[0] + num2); } }//如果参数长度为1，执行第一个if；如果为2，执行else if。这里执行else if，这里的arguments[0] = num1. arguments的值永远与对应命名参数的值保持同步： function doAdd(num1, num2) { arguments[1] = 10; sum = arguments[0] + num2; console.log(sum); }//这里修改了arguments[1]也就是修改了num2。不过这里不是说读取这两个值都会访问相同的空间，他们的内存空间是独立的，但它们的值会同步。但这种影响是单向的，修改命名参数不会改变arguments的值。 //同时，如果只传入一个参数，那么为arguments[1]设置的值不会反应到命名参数中。因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。 PS:ES中所有参数传递的都是值，不可能通过引用传递参数。 5.2 没有重载 ▲ES不能像传统意义上那样实现重载。但是可以通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:19:30 "},"part3/javascript_high_level/3.html":{"url":"part3/javascript_high_level/3.html","title":"3.变量、作用域、内存和引用类型","keywords":"","body":"1. 变量、作用域和内存问题 1、ES中所有函数的参数都是按值传递的，意思就是把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 function addTen(num) { num += 10; return num; } var count = 20; var result = addTen(count); alert(count); //20，没有变化 alert(result); //30 2、typeof检测变量是字符串、数值和布尔值还是undefined，如果是null和一个对象，返回object。 var s = \"shuai\"; var i = 22; var u; var n = null; var o = object(); console.log(typeof s); //string console.log(typeof i); //number console.log(typeof u); //undefined console.log(typeof n); //object console.log(typeof o); //object 3、执行环境和作用域： 1.Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法。 2.每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ES程序中的执行流正是由这个方便的机制控制着。 3.当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 4、没有块级作用域：在其他类C的语言中，由花括号封闭的代码块都有自己的作用域，但是JS并没有自己的块级作用域。 if语句中的变量声明会将变量添加到当前的执行环境中: if(true) { var color = \"blue\"; } console.log(color); //\"blue\" 切记使用for语句时的这一差异: for (var i=0; i 5、垃圾收集：JS程序内存回收实现了自动管理，自动释放内存。但是，系统分配给Web浏览器得到可用内存数量通常要比分配给桌面应用程序的少。（这是出于安全考虑，防止运行JS的网页耗尽全部系统内存而导致系统崩溃。） 所以，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式就是，为执行中的代码值保存必要的数据，一旦数据不会再使用到，最好将其值设置为null来释放它的引用——这就是“==解除引用==”。（这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动解除引用。）（解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。） Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:20:43 "},"part3/javascript_high_level/4.html":{"url":"part3/javascript_high_level/4.html","title":"4.Array","keywords":"","body":" 目录 1.延迟脚本和异步脚本 2.Array类型的方法 1.延迟脚本和异步脚本 延迟脚本：只适用于外部脚本文件，脚本会被延迟到整个页面都解析完毕后再运行。（相当于告诉浏览器立即下载，但延迟执行） 异步脚本：只适用于外部脚本文件，告诉浏览器立即下载文件，但是并不保证按照指定这些脚本的先后顺序执行。(建议异步脚本不要在加载期间修改DOM。) 2.Array类型的方法 方法 类别 功能 ▲ push() 栈方法 将参数添加到数组末尾 pop() 栈方法 移除数组末尾最后一项 shift() 队列方法 移除数组第一项 unshift() 队列方法 在数组前端添加项 reverse() 重排序方法 反转数组项顺序 sort() 重排序方法 从小到大排列数组，可接收比较函数作为参数 ▲ slice() 操作方法 接收数组起始和结束位置并返回相应的数组 splice() 操作方法 删除，插入，替换 indexOf() 位置方法 查找某项(值必须完全相等)在数组中的位置 以下方法接受两个参数，前五个方法参数是函数和作用域对象： 方法 类别 功能 every() 迭代方法 如果该函数对每一项都返回true，则返回true。 some() 迭代方法 如果该函数对某一项返回true，则返回true。 ▲ filter() 迭代方法 返回该函数会返回true的项组成的数组。 ▲ forEach() 迭代方法 对每一项执行某些操作，没有返回值。 ▲ map() 迭代方法 返回每次函数调用的结果组成的数组。 reduce() 归并方法 从头到尾逐个遍历，迭代数组中的所有项（见第7点） 1.栈方法：后进先出 push():接收任意数量的参数，将它们逐个添加到数组末尾，返回修改后的数组长度。 pop():从数组末尾移除最后一项，减少数组的length值，返回移除的项。 2.队列方法：先进先出 shift():移除数组第一项并返回该项，将数组长度减1。 unshift():在数组前端添加任意项并返回新数组的长度。 3.重排序方法 reverse():反转数组项的顺序。 sort():比较数组转型的字符串，从小到大排列。可以接收比较函数作为参数。 function compare(v1, v2) { if (v1 v2) { return 1; } else { return 0; } } var numArray = [11, 24, 55, 90, 67]; numArray.sort(compare); console.log(numArray); // 11,24,55,67,90 4.操作方法 slice():接收一个或两个参数，即返回项的起始和结束位置。不会影响原始数组。 var num = [1, 2, 3, 4, 5]; var numFind_1 = num.slice(1); var numFind_2 = num.slice(1,4); console.log(numFind_1); // 2, 3, 4, 5 返回从指定位置开始到数组末尾所有项。 console.log(numFind_2); // 2, 3, 4 返回从指定位置开始到指定结束项。 splice():接收多个参数。 删除：删除任意数量的项，指定前两个参数，删除的第一项的位置和要删除的项数。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(0,3); // 删除第一项开始的前三项 console.log(numArray); // 90, 67 插入：插入任意数量的项，起始位置，0(删除的项数)，以及插入的项。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(1, 0, 88); // 在第二项的位置插入88 console.log(numArray); // 11, 88, 24, 55, 90, 67 替换：指定位置，删除某项，插入替换项。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(1, 1, 88); // 先删除第二项，再在第二项的位置插入88 console.log(numArray); // 11, 88, 55, 90, 67 5.位置方法 indexOf():返回查找的项在数组中的位置，但是查找的项的值必选严格相等。 var numArray = [11, 24, 55, 90, 67]; console.log(numArray.indexOf(90)); // 3，表示90为数组中第三位，第四项 6.迭代方法： 1.每个迭代方法都会接收两个参数：要在==数组中的每一项==都运行的函数和（可选的）运行该函数的作用域对象-影响this的值。 2.传入这些方法中的函数会接收三个参数：数组某项的值(item)，该项在数组中的位置(index)，数组对象本身(array)。 every():如果该函数对每一项都返回true，则返回true。 some():如果该函数对某一项返回true，则返回true。 filter():返回该函数会返回true的项组成的数组。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var everyResult = numArray.every(function(item, index, array){ return (item > 3); }); console.log(everyResult); // false var someResult = numArray.some(function(item, index, array){ return (item > 3); }); console.log(someResult); // true var filterResult = numArray.filter(function(item, index, array){ return (item > 3); }); console.log(filterResult); // [4, 5, 6, 7] forEach():对每一项执行某些操作，没有返回值。 map():返回每次函数调用的结果组成的数组。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var a = numArray.map( function(item, index, array) { return item + 10; }); console.log(a); // [11, 12, 13, 14, 15, 16, 17] numArray.forEach(function(item, index, array) { // 执行某些操作 }); 7.归并方法 reduce():从头到尾逐个遍历，迭代数组中的所有项，然后构建一个最终返回的值。 1.接收两个参数：一个在每一项上调用的函数和(可选的)作为归并基础的初始值。 2.传入的函数接收四个参数：前一个值(prev)，当前值(cur)，项的索引(index)，数组对象(array)。这个函数返回的任何值都会作为第一个参数自动传给下一项。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var sum = numArray.reduce(function(prev, cur, index, array){ return prev + cur; }); console.log(sum); // 28 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:20:24 "},"part3/javascript_high_level/5.html":{"url":"part3/javascript_high_level/5.html","title":"5.Date Function Global Math","keywords":"","body":" 目录 1.Date()类型的组件方法 2.Function类型 2.1 函数声明与函数表达式 2.2 作为值的函数 2.3 函数内部属性 2.4 函数属性和方法 3.单体内置对象 3.1 Global对象 3.2 Math对象 1.Date()类型的组件方法 Date()方法使用实例: var myTime = new Date(); console.log(myTime.toLocaleString()); // 2017/10/7 下午4:52:53 日期/时间组件方法： 方法 说明 getFullYear() 取得四位数的年份 getMonth() 返回日期中的月份，0表示一月，11表示12月 getDate() 返回日期月份中的天数 getDay() 返回日期中星期几，0表示星期日，6表示星期六 getHours() 返回日期中的小时数(0-23) getMinutes() 返回日期中的分钟数(0-59) getSeconds() 返回日期中的秒数(0-59) getMilliseconds() 返回日期中的毫秒数 ▲ toLocaleDateString() 获取当前日期 ▲ toLocaleTimeString() 获取当前时间 ▲ toLocaleString() 获取当前日期与时间 2.Function类型 2.1 函数声明与函数表达式 函数声明提升：解析器向执行环境加在数据的时候，对函数声明和函数表达式并非一视同仁。==解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。== 2.2 作为值的函数 函数名本身就是变量，所以函数也可以作为值来使用。 根据对象数组某个属性排序： function createComparisonFunction(propertyName) { return function(object1, object2){ var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 value2) { return 1; } else { return 0; } }; } // 使用上面的函数createComparisonFunction var data = [ {name:\"ZhouShao\", age:25 }, {name:\"XuShuai\", age:20 }, {name:\"CaiShao\", age:22 } ]; data.sort(createComparisonFunction(\"name\")); console.log(data); // CaiShao...XuShuai...ZhouShao... data.sort(createComparisonFunction(\"age\")); console.log(data); // XuShuai...CaiShao...ZhouShao... 2.3 函数内部属性 虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。 阶乘函数例子： function factorial(number){ if (number this引用的是函数 据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。 2.4 函数属性和方法 ▲ 每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。对于ES中的引用类型而言，prototype是保存它们所有实例方法的真正所在。 ▲ 每个函数都包含两个非继承而来的方法：apply()和call()。它们的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。 apply()方法：接收两个参数，第一个是在其中运行函数的作用域，另一个是参数数组(第二个参数可以是Array实例，也可以是arguments对象)。 function sum(a, b){ return a + b; } function callSum1(a, b){ return sum.apply(this, arguments); // 传入arguments对象 } function callSum2(a, b){ return sum.apply(this, [a, b]); // 传入数组 } console.log(callSum1(5, 6)); // 11 console.log(callSum2(5, 6)); // 11 call()方法：第一个参数是this值，其余参数都直接传递给函数。 function sum(a, b){ return a + b; } function callSum(a, b){ return sum.call(this, a, b); // 传入arguments对象 } console.log(callSum(6, 7)); // 13 ▲ apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域。使用call()扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。 var color = 'purple'; var o = { color : \"yellow\" }; function sayColor(){ console.log(this.color); } sayColor(); // purple sayColor.call(this); // purple sayColor.call(window); // purple sayColor.call(o); // yellow ES5还定义了bind()方法，它会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。 var color = 'purple'; var o = { color : \"yellow\" }; function sayColor(){ console.log(this.color); } var say = sayColor.bind(o); // 把o对象传入给saycolor()并创建了say()函数，所以say()函数的this值等于o。 say(); // yellow 3.单体内置对象 3.1 Global对象 事实上，全局变量或全局函数——所有在全局作用域中定义的属性和函数，都是Global对象的属性。 encodeURI()和encodeURIComponent()方法：前者将空格转码为20%，后者将所有非字母数字字符转码为20%。(一般使用后者使用更多)。可以分别使用decodeURI()和decodeURIComponent()进行解码。 var uri = \"http://www.baidu.com/illegal value.html#start\"; // http://www.baidu.com/illegal%20value.html#start console.log(encodeURI(uri)); // http%3A%2F%2Fwww.baidu.com%2Fillegal%20value.html%23start console.log(encodeURIComponent(uri)); -eval()方法：只接受一个参数——ES或JS要执行的字符串。 eval(\"console.log('123')\"); // '123' 3.2 Math对象 方法 作用 Math.max() 取得最大值 Math.min() 取得最小值 Math.ceil() 执行向上舍入 Math.floor() 执行向下舍入 Math.round() 执行标准舍入 ▲ Math.random() 返回大于等于0小于1的随机数 补充：如何向Math.max()/Math.min()传入数组： var arr = [1, 2, 3, 4, 5]; var max = Math.max.apply(Math, arr); // 确定一个数组中的最大值 ES6的写法 Math.max(...arr); 补充：如何返回某个区间的随机数，Math.random(): 整数值 = Math.floor(Manth.random() * 可能值的总数 + 第一个可能的值)。 // 选择一个介于 2 到 10 之间整数书值。 var num = Math.floor(Math.random() * 9 + 2); // 2~10 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:21:09 "},"part3/javascript_high_level/6.html":{"url":"part3/javascript_high_level/6.html","title":"6.对象设计","keywords":"","body":" 目录 1.面向对象的程序设计 1.1 创建对象 1.2 继承 1.面向对象的程序设计 1.1 创建对象 六种模式：工厂模式、构造函数模式、原型模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式。 ▲ 创建对象的最佳方式是组合使用构造函数模式和原型模式，使用构造函数定义实例属性，而使用原型模式定义共享的属性和方法。 组合使用构造函数模式和原型模式： 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。这样的话，不仅支持向构造函数传递参数，而且每个实例都会有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度地节省了内存。 // 构造函数模式用于定义实例属性 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = [\"XiangShuai\", \"ZhanShen\"]; } // 原型模式用于定义方法和共享的属性 Person.prototype = { // 默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性是一个指向prototype属性所在函数的指针 // 这里的Person.prototype.constructor指向Person constructor : Person, sayName : function() { console.log(this.name); } } var person1 = new Person(\"Kalen\", 30, \"Software Engineer\"); var person2 = new Person(\"Xushao\", 21, \"Doctor\"); person1.friends.push(\"Xushao\"); console.log(person1.friends); // [\"XiangShuai\", \"ZhanShen\", \"Xushao\"] console.log(person2.friends); // [\"XiangShuai\", \"ZhanShen\"] console.log(person1.friends === person2.friends); // false console.log(person1.sayName === person2.sayName); // true 1.2 继承 六种方式：原型链、借用构造函数、组合继承、原型式继承、寄生式继承、寄生组合式继承。 ▲ 组合继承：这种模式使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 function SuperType(name) { this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function() { console.log(\"name:\" + this.name); }; function SubType(name, age) { // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(\"age:\" + this.age); }; // 这样定义的话，可以让两个不同的SubType既分别拥有自己的属性，又可以使用相同的方法了。 var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); console.log(\"instance1.colors:\" + instance1.colors); // instance1.colors:red,blue,green,black instance1.sayName(); // name:Nicholas instance1.sayAge(); // age:29 var instance2 = new SubType(\"Greg\", 22); console.log(\"instance2.colors:\" + instance2.colors); // instance2.colors:red,blue,green instance2.sayName(); // name:Greg instance2.sayAge(); // age:22 ▲ object.create(): // 实现继承 var extend = function(Child, Parent) { // 拷贝Parent原型对象 Child.prototype = Object.create(Parent.prototype); // 将Child构造函数赋值给Child的原型对象 Child.prototype.constructor = Child; } // 实例 var Parent = function () { this.name = 'Parent'; } Parent.prototype.getName = function () { return this.name; } var Child = function () { Parent.call(this); // call super constructor. } extend(Child, Parent); var child = new Child(); console.log(child.getName()) Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:22:04 "},"part3/javascript_high_level/7.html":{"url":"part3/javascript_high_level/7.html","title":"7.闭包","keywords":"","body":" 目录 1.函数表达式 1.1 递归 ▲▲▲1.2 闭包 1.2.1 闭包与变量 1.2.2 关于this对象 1.2.3 内存泄漏 ▲ 1.3 模仿块级作用域 1.4 私有变量 > 1.4.1 静态私有变量 1.函数表达式 定义函数的方式有两种：一种是函数声明，另一种是函数表达式。 关于函数声明，它的一个重要特征就是函数声明提升，在执行代码之前会先读取函数声明，这意味着可以把函数声明放在调用它的语句后面。 sayHi(); function sayHi() { console.log(\"Hi!\"); }; 关于函数表达式，创建一个函数将它赋值给某个变量，这种情况下创建的函数叫做==匿名函数==。 var functionName = function (arg0, arg1) { // 函数主体 }; 1.1 递归 递归是一个函数通过名字调用自身情况下构成的。 arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，同时它可以实现递归调用时的松耦合。 function factorial(num) { if (num ▲▲▲ 1.2 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。（所以创建闭包的常见方式，就是在一个函数内部创建另一个函数。） 一般的函数调用执行：当某个函数被调用时，会创建一个执行环境以及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。后台的每个执行环境都有一个变量对象（全局环境的变量对象始终存在，而局部环境的变量对象则只在函数执行的过程中存在）。所以，==无论什么时候在函数中访问一个变量，都会从作用域链中搜索具有相应名字的变量。一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)==。 function compare(value1, value2) { if (value1 value2) { return 1; } else { return 0; } } var result = compare(5, 10); 以上代码先定义了compare()函数，然后在全局作用域中调用了它。 在调用时，会创建一个包含arguments、value1和value2的活动对象。 就compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。 ▲ 闭包的执行调用：在函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。外部函数执行完毕后，它的活动对象也不会被销毁，因为内部内部函数的作用域链仍然在引用这个活动对象(换句话说，当外部函数返回之后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到内部函数被销毁后，外部函数的活动对象才会被销毁——比如手工解除对内部函数的引用)。【所以，由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包】。 1.2.1 闭包与变量 闭包只能取得包含函数中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量。 例如： function createFunction () { var result = new Array(); for (var i = 0; i 1.2.2 关于this对象 匿名函数的执行环境有全局性，其this对象通常指向window。不过，==每个函数在被调用时都会自动取得两个特殊变量：this和arguments。== 在闭包中调用this对象和arguments时，把外部作用域中的this对象和arguments保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。 var name = \"XuShao\"; var obj = { name : \"XiangShuai\", // 一般函数引用 getName : function(){ return this.name; }, // 闭包调用时，不转换this对象 getNameFunc1 : function () { return function () { return this.name; }; }, // 闭包调用时，转换this对象 getNameFunc2 : function () { // 定义匿名函数之前，把this对象值赋给that对象，这样定义闭包后，闭包也可以访问这个变量了 var that = this; return function () { return that.name; }; } }; console.log(obj.getName()); // \"XiangShuai\" console.log(obj.getNameFunc1()()); // \"XuShao\" console.log(obj.getNameFunc2()()); // \"XiangShuai\" 1.2.3 内存泄漏 如果闭包的作用域链保存了一个HTML元素，那么该元素无法被销毁。 点击我 function assignHandler() { var element = document.getElementById(\"someElement\"); // element.onclick = function () { // console.log(element.id); // }; // 我们使用垃圾回收机制接触引用让值脱离执行环境，以便垃圾收集器下次回收，确保正常回收其占用的内存。 // 把element.id的一个副本保存在一个变量中，在闭包中引用该变量消除了循环引用。 var id = element.id; element.onclick = function () { console.log(id); } // 闭包会引用包含函数的整个活动对象，其中会至少保存一个引用，所以这里有必要把element设置为null,解除对DOM对象的引用。 element = null; } assignHandler(); ▲ 1.3 模仿块级作用域 JS没有块级作用域的概念，但是可以用匿名函数来模仿块级作用域(也称私人作用域)。 例：立即执行的匿名函数 (function () { // 这里是块级作用域 })(); // 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。 只是临时需要一些变量，就可以使用私有作用域，在匿名函数中定义的任何变量，都会在执行结束时被销毁： var len = 5; function outputNumber(count) { (function () { for (var i = 0; i 推荐使用该技术，一方面可以避免过多的全局变量和函数命名冲突，不必担心搞乱全局作用域；另一方面这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链了。 (function () { var now = new Date(); if (now.getMonth() == 0 && now.getDate() == 1) { console.log(\"Happy new year!\"); } })(); 1.4 私有变量 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。 有权访问私有变量和私有函数的公有方法称为==特权方法==。有两种在对象上创建特权方法的方式。一种是在构造函数中定义特权方法，但构造函数模式的缺点是针对每个实例都会创建同样一组新方法，所以使用==静态私有变量==实现特权方法就可以避免这个问题。 1.4.1 静态私有变量 在私有作用域(块级作用域)中定义私有变量或函数可以创建特权方法： (function () { // 变量name是一个静态的、由所有实例共享的属性。 var name = \"\"; // 初始化未经声明的变量，总是会创建一个全局变量。 // 所以Person就成了一个全局变量，能够在私有作用域之外被访问到。 Person = function (value) { name = value; }; Person.prototype.getName = function () { return name; }; Person.prototype.setName = function (value) { name = value; }; })(); var person1 = new Person(\"Nicholas\"); console.log(person1.getName()); // \"Nicholas\" person1.setName(\"Greg\"); console.log(person1.getName()); // \"Greg\" // 调用setName()或新建一个Person实例都会赋予name属性一个新值 var person2 = new Person(\"XuShao\"); console.log(person1.getName()); // \"XuShao\" console.log(person2.getName()); // \"XuShao\" person1.setName(\"Greg\"); console.log(person1.getName()); // \"Greg\" console.log(person2.getName()); // \"Greg\" 附：多查找作用域链中的一个层次，就会在一定程度上影响查找速度。这正是使用闭包和私有变量的一个不足之处。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:22:21 "},"part3/javascript_high_level/8.html":{"url":"part3/javascript_high_level/8.html","title":"8.window location 间歇和超时","keywords":"","body":" 目录 window对象 > 1.1 屏幕/浏览器/元素宽高 1.2 导航和打开窗口 1.3 系统对话框 间歇调用和超时调用 location对象 > 3.1 位置操作 1.window对象 浏览器中，window对象既是通过JS访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。 定义全局变量和在window对象上定义属性的一点差别：全局变量不能通过delete操作符删除，但window对象上定义的属性可以。 var age = 29; window.color = \"red\"; delete window.age; // 无效 delete window.color; // 删除 console.log(window.age); // 29 console.log(window.color); // undefined 1.1 屏幕/浏览器/元素宽高 console.log(document.body.clientWidth); //网页可见区域宽(body) console.log(document.body.clientHeight); //网页可见区域高(body) console.log(document.body.offsetWidth); //网页可见区域宽(body)，包括border、margin等 console.log(document.body.offsetHeight); //网页可见区域宽(body)，包括border、margin等 console.log(document.body.scrollWidth); //网页正文全文宽，包括有滚动条时的未见区域 console.log(document.body.scrollHeight); //网页正文全文高，包括有滚动条时的未见区域 console.log(document.body.scrollTop); //网页被卷去的Top(滚动条) console.log(document.body.scrollLeft); //网页被卷去的Left(滚动条) console.log(window.screenTop); //浏览器距离Top console.log(window.screenLeft); //浏览器距离Left console.log(window.screen.height); //屏幕分辨率的高 console.log(window.screen.width); //屏幕分辨率的宽 console.log(window.screen.availHeight); //屏幕可用工作区的高 console.log(window.screen.availWidth); //屏幕可用工作区的宽 1.2 导航和打开窗口 使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法接收四个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值(通常只传递一个参数，最后一个参数只在不打开新窗口的情况下使用)。 (function(){ var xixi = document.getElementById(\"xixi\"); xixi.onclick = function(){ // 新的页面打开百度链接 window.open(\"https:www.baidu.com\",\"_blank\"); } })(); 1.3 系统对话框 浏览器通过alert()、confirm()、prompt()方法可以调用系统对话框向用户显示消息。通过这几个方法打开的对话框都是同步和模态的(也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又恢复执行)。 2.间歇调用和超时调用 ==超时调用==：使用window对象的setTimeout()方法，它接收两个参数，第一个参数一般是函数，第二个参数是以毫秒表示的时间。 如果要取消尚未执行的超时调用，使用clearTimeout()方法并将相应的超时调用ID作为参数传递给它。 // 不推荐第一个参数使用字符串，会导致性能损失，推荐的调用方式如下： var timeoutId = setTimeout(function() { console.log(\"123\"); }, 1000) clearTimeout(timeoutId); // 取消超时调用 ==间歇调用==：按照指定时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval(),接收的参数是要执行的函数和每次执行前需要等待的毫秒数。 // 每隔5秒输出 setInterval(function() { console.log(\"123\"); }, 1000) 注：在使用超时调用时，没必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境中，很少使用真正的间歇调用，原因是一个间歇调用可能会在前一个间歇调用结束之前启动。所以像下面这样使用超时调用，则完全可以避免这一点： vfunction incrementNumber() { num++; // 如果执行次数未达到max的值，则设置另一次超时调用 if (num 3.location对象 location对象很特别，它既是window对象的属性，也是document对象的属性。换句话说：window.location和document.location引用的是同一个对象。 常用location对象属性： 属性名 | 说明 ---|--- hash | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 search | 返回URL中的查询字符串，这个字符串以问号开头 hostname | 返回不带端口号的服务器名称 pathname | 返回URL中的目录或文件名 port | 返回URL中指定的端口号，如果URL中不包含端口号，则这个属性返回空字符串 3.1 位置操作 改变浏览器位置的方法： 法一： window.location = \"https://www.baidu.com\"; 法二： location.href = \"https://www.baidu.com\"; 通过hash、search、hostname、pathname和port修改URL： // 假设初始值为\"https://www.baidu.com\", 每次修改location页面都会以新URL重新加载 // 将URL修改为\"https://www.baidu.com/#section\" loction.hash = \"#section\"; // 将URL修改为\"https://www.baidu.com/?name=xuqingfeng\" location.search = \"?name=xuqingfeng\"; // 将URL修改为\"https://www.taobao.com\" location.hostname = \"www.taobao.com\"; // 将URL修改为\"https://www.taobao.com/myId\" location.pathname = \"myId\"; // 将URL修改为\"https://www.taobao.com:8080/myId\" location.port = \"8080\"; reload()重新加载当前显示页面。位于reload()后的代码可能不会执行，最好是将reload()放在最后一行 location.reload(); // 重新加载，可能从缓存中加载 location.reload(true); // 重新加载，从服务器重新加载 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:22:46 "}}