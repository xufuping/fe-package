{"./":{"url":"./","title":"写在前面","keywords":"","body":"写在前面 本书主要记录了笔者前端学习的经验，包括搭建前端开发环境，前端工作中的知识要点以及技术性读书笔记。 前端开发环境 这一章主要描述了作为前端开发者的常用工具 技术类知识零碎 这一章主要记录了平时学习和工作中的零碎知识要点 技术类读书笔记 这一章主要是阅读技术类书目的读书笔记 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 20:57:52 "},"part1/abase.html":{"url":"part1/abase.html","title":"前端基础环境搭建","keywords":"","body":"前端基础环境搭建 打造一个干净舒适快捷的前端开发环境，我们的目的是“更高、更快、更强”。 Vscode 前端代码开发工具配置 终端 又高效又时尚的终端 Iterm 基于 mac 的升级版终端 Shell 一些 linux 常用命令 Vim 在 linux 系统的内置编辑器 Git 高效的团队合作开发 Chrome 强大的前端调试工具 Mac 释放鼠标，做一个牛掰的键盘侠 抓包 - Charles，它不仅仅是一个花瓶 Postman 接口测试 ip 代理 - iHosts Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-03 14:05:20 "},"part1/shell.html":{"url":"part1/shell.html","title":"shell","keywords":"","body":"终端 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-03 14:16:28 "},"part2/1_fe_useful.html":{"url":"part2/1_fe_useful.html","title":"前端代码常用小操作","keywords":"","body":"前端代码常用小操作 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 20:56:30 "},"part3/javascript_high_level/1.html":{"url":"part3/javascript_high_level/1.html","title":"1.简介","keywords":"","body":"1.JavaScript 简介 1.1 JS 实现 一个完整的 JS 实现应该由下列三个不同的部分组成：==核心(ECMAScript)==、==文档对象模型(DOM)==、==浏览器对象模型(BOM)==. 1.1.1 核心(ECMAScript) ECMAScript，由 ECMA-262 定义，提供核心语言功能。 ECMAScript 与 Web 浏览器没有依赖关系，Web 浏览器只是 ECMAScript 可能的宿主环境之一。 1.1.2 文档对象模型(DOM) DOM 主要负责提供访问和操作网页内容的方法和接口。 DOM 把整个页面映射为一个多层节点结构(表示文档的树形图)，借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。 1.1.2.1 DOM 级别 1.1.2.1.1 DOM1 级别： DOM1 级别由两个模块组成：DOM 核心和 DOM HTML. DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。 DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。 1.1.2.1.2 DOM2 级别： DOM2 在 DOM 的基础上又扩充了(DHTML 一直都支持的)鼠标和用户界面事件、范围、遍历(迭代 DOM 文档的方法)等细分模块，而且通过对象接口增加了对 CSS 的支持。 DOM2 级引入了下列新模块，也给出了众多新类型和新接口的定义： DOM视图：定义了跟踪不同文档（例如，应用CSS之前和之后的文档）视图的接口； DOM事件：定义了事件和事件处理的接口； DOM样式：定义了基于CSS为元素应用样式的接口； DOM遍历和范围：定义了遍历和操作文档树的接口。 1.1.2.1.3 DOM3 级别： 进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存模块中定义；新增了验证文档的方法——在 DOM 验证模块中定义。同时扩展了 DOM 核心，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base. （DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM。） 1.1.3 浏览器对象模型(BOM) BOM 提供与浏览器交互的方法和接口，可以访问和操作浏览器窗口。 从根本上讲，BOM 只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分，下面就是一些扩展： 弹出新浏览器窗口的功能； 移动、缩放、关闭浏览器窗口的功能； 提供浏览器详细信息的navigator对象； 提供浏览器所加载页面的详细信息的location对象； 提供用户显示器分辨率详细信息的screen对象； 对cookies的支持； 像XMLHttpRequest和IE 的 ActiveXObject 这样的自定义对象。 （HTML5 致力于把很多 BOM 功能写入正式规范） 2.在 HTML 中使用 JavaScript 2.1 元素 六个属性 async 【异步脚本】可选。表示立即下载脚本，只对外部脚本文件有效。(标记为async的脚本并不保证按照指定它们的先后顺序执行。) //使用：直接写入async，在XHTML文档中写入 async=\"async\" charset 可选。表示通过src指定的代码的字符集。（被大多数浏览器忽略，少有人用） defer 【延迟脚本】可选。表示脚本延迟到文档完全被解析和显示之后再执行(但不影响下载次序)。只对外部脚本文件有效。 // 使用：直接写入 defer=\"defer\" language 已废弃。 src 可选。导入外部脚本文件。 type 可选。表示编写代码用的脚本语言的内容类型(MIME类型)，一般值为\"text/javascript\". // 只要不出现defer和async属性，浏览器都会按照元素在页面中出现的先后顺序对它们依次进行解析。 2.1.1 标签的位置 放在，必须等到全部 JavaScript 代码被下载解析执行后才能开始呈现页面的内容。这很有可能导致浏览器在呈现页面时出现明显的延迟，造成不好的用户体验。 所以，为了避免这个问题，现代 Web 应用程序一般把 JavaScript 引用放在元素中，放在页面的内容后面，加强用户体验。 2.1.2 XHTML 严格模式 XHTML 结合了 XML 部分的强大功能以及 HTML 大多数的简单特性，XHTML 要求更加严谨，相对 HTML 的几大区别： XHTML 要求争取额嵌套； XHTML 所有元素必须关闭； XHTML 区分大小写； XHTML 属性值要用双引号； XHTML 用id属性代替name属性； XHTML 特殊字符的处理。 2.2 嵌入代码与外部文件 外部 JS 的优势： 可维护性：专注编辑JS 可缓存：同代码多样使用 适应未来：外部JS无序使用XHTML或注释hack，HTML和XHTML包含外部文件的语法是相同的。 2.3 文档模式 最初的两种文档模式：混杂模式和标准模式。 所有浏览器会默认开启混杂模式，不同浏览器在这种模式下行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。 开启标准模式： 触发标准模式: 触发准标准模式: 2.4 元素 浏览器不支持脚本或者脚本被禁用，才会触发. noscript 本页面JavaScript脚本被禁用 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:00:56 "},"part3/javascript_high_level/2.html":{"url":"part3/javascript_high_level/2.html","title":"2.基本概念","keywords":"","body":"1.语法，关键字和保留字，变量 1.1语法 1.ECMAScript区分大小写； 2.标识符(变量、函数、属性的名字或者函数参数)：第一个字符必须是字母、下划线或一个美元符号($)，其他字符可以是字母、下划线、美元符号或数字(建议采用驼峰命名)； 3.严格模式：为JS定义了一种不同额度解析与执行模型，对ES3的一些不确定行为进行处理，对某些不安全操作也会抛出错误。启用严格模式，在脚本顶部添加代码：\"use strict\"。 4.语句：分号结尾，使用代码快写法在流控制语句等语句中使用{} 1.2关键字和保留字 不要使用关键字和保留字作为标识符和属性名，以便与将来的ECMAScript版本兼容。常见的有： 关键字: break,do,typeof,case,else,new,var continue,for,switch,while,function this,with,default,if,throw,delete,try 保留字: abstract,int,short,boolean,export static,byte,long,super,char,final class,float,throws,const,goto,private debugger,protected,double,import,public 1.3变量 ES变量是松散类型的，可以保存任何类型的数据。 var message = \"hi\"; 2.数据类型 2.1 typeof操作符 作用：检测给定变量的数据类型： 值未定义——\"undefined\" 值是布尔值——\"boolean\" 值是字符串——\"string\" 值是数值——\"number\" 值是对象或null——\"object\"(null被认为是一个空的对象引用) 值是函数——\"function\" 示例： var message = \"some string\"; console.log(typeof message); // \"string\" ▲typeof是一个操作符，不是一个函数。 2.2 Undefined类型 未被初始化和未被声明的对象，都会返回undefined。 var message; //var age; console.log(message); // \"undefined\" console.log(age); // 产生错误 2.3 Null类型 空对象 ▲推荐写法： 如果定义的变量准备将来用于保存对象，可以把变量初始值设为null。 这样没有被声明的变量返回undefined，没有被初始化的变量返回null。 //var message; var age = null; console.log(message); // undefined console.log(age); // null console.log(typeof age); // object 2.4 Boolean类型 true和false区分大小写。下面是Boolean转换： 数据类型 转化为true的值 转换为false的值 Boolean true false String 非空字符串 \"\"（空字符串） Number 非零数字（包括无穷大） 0和NaN Object 任何对象 bull Undefined n/a【不适用】 undefined 对任何数据类型的值调用Boolean()函数，总会返回一个Boolean值。Boolean转换对理解流控制语句很重要，下面是各种数据类型及其对应的转换规则： var message = \"hello!\"; if (message){ alert(\"这是一个非空字符串\"); } else { alert(\"这是一个空字符串\"); } // 这是一个非空字符串，因为message里有字符串。 2.5 Number类型 提示：不要测试特定的浮点数值，它们计算会产生舍入误差，这是基于IEEE754数值的浮点计算的通病； 2.5.1 NaN(非数值，Not a Number) isNaN()函数接受一个参数，确定这个参数是否“不是数值”。 console.log(isNaN(NaN)); // true console.log(isNaN(10)); // false(10是一个数值) console.log(isNaN(\"10\")); // false(数字字符串可以被转换成数值10) console.log(isNaN(\"blue\")); // true(这个字符串不能转换成数值) console.log(isNaN(true)); // false(true可以被转换成数值1) 2.5.2 数值转换 2.5.2.1 Number()用于任何数据类型数值转换 1. 如果是Boolean值，true和false将分别被转换为1和0； 2. 如果是数字值，传入和返回； 3. 如果是null值，返回0 4. 如果是undefined，返回NaN； 5. 如果是字符串： (1). 如果字符串只有数字，权当十进制并转换为十进制，例如“011”转换为“11”，忽略前导0； (2). 如果字符串只有浮点数，转换为浮点数，忽略前导0； (3). 如果有十六进制数转换为相同大小的十进制数值，例如“0xf”转换为“15”； (4). 如果字符串为空，将其转换为0，例如“ \" \" ”转换为“0”； 6. 如果是对象，则调用valueOf()方法，然后按照前面的规则转换返回的值。 如果转换结果为NaN，则调用对象的toString()方法，然后再次按照前面的规则转换返回的字符串值。 示例： var num1 = Number(\"hi\"); var num2 = Number(\" \"); var num3 = Number(\"011\"); var num4 = Number(\"true\"); var num5 = Number(\"undefined\"); var num6 = Number(\"null\"); var num7 = Number(\"0xD\"); console.log(num1,num2,num3,num4,num5,num6,num7); //NaN,0,11,true,NaN,0,13 2.5.2.2 parseInt()用于字符串数值转换为整数 parseInt()可以识别各种整数格式： var num1 = parseInt(\"1234blue\"); var num2 = parseInt(\" \"); var num3 = parseInt(\"0xA\",16); var num4 = parseInt(\"70\",8); // ES5和严格模式不具有解析八进制能力，必须写明基数才行 var num5 = parseInt(\"11\",2); var num6 = parseInt(\"22.5\");// 小数点后面的数字被省略掉 var num7 = parseInt(\"15\"); // 默认十进制转换 console.log(num1,num2,num3,num4,num5,num6,num7); // 1234,NaN,10,56,3,22,15 2.5.2.3 parseFloat()用于字符串数值转换为小数 parseFloat()只解析十进制数值： var num1 = parseFloat(\"1234blue\"); var num2 = parseFloat(\"0xA\"); var num3 = parseFloat(\"22.5\"); var num4 = parseFloat(\"22.34.5\"); var num5 = parseFloat(\"098.5\"); var num6 = parseFloat(\"3.125e7\"); console.log(num1,num2,num3,num4,num5,num6); //1234 0 22.5 22.34 98.5 31250000 2.6 String类型 字符串，建议采用双引号，也可以用单引号。 2.6.1 字符字面量 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\' 单引号 \\\" 双引号 2.6.2 转换为字符串 toString()方法和String()方法: var num = 10; console.log(num.toString()); // \"10\" console.log(num.toString(2)); // \"1010\" console.log(num.toString(8)); // \"12\" console.log(num.toString(16)); // \"a\" var value = true; console.log(value.toString()); // \"true\" var value = null; console.log(value.toString()); // Uncaught TypeError: Cannot read property 'toString' of null null和undefined没有toString()方法，但是String()函数不仅有toString()方法的效用，还可以返回这两个值的字面量。 var value1 = null; var value2 = undefined; console.log(String(value1)); // \"null\" console.log(String(value2)); // \"undefined\" 2.7 Object类型 new操作符创建一个对象 var o = new Object(); Object有下列属性和方法： 1.hasOwnProperty(propertyName)：检查给定的属性是否在当前对象中。 var o = new Object(); o.name = \"xushuai\"; console.log(o.hasOwnProperty(\"name\")); // true 2.isPrototypeof(object):检查传入的对象是否是另一个对象的原型； 3.propertyIsEnumerable(propertyName)：检查给定的属性是否可以用for-in语句； 4.toString():返回对象的字符串表示； 5.valueOf()：返回对象的字符串、数值或布尔值表示，很多时候与toString()方法返回值相同。 3.操作符 【一元操作符（++，--，+，-,+=,-=）、位操作符（~，&，|，^，>,>>>）、乘性操作符（*，/，%）、加性操作符(+,-)、关系操作符（,==）略过】 3.1 布尔操作符 3.1.1 逻辑非(!) 1.如果操作数是一个对象，返回false； 2.如果操作数是一个空字符串，返回true；如果操作数是一个非空字符串，返回false； 3.如果操作数是数值0，返回true；如果操作数是任意非0数值（包括Infinity），返回false; 4.如果操作数是null,NaN,undefined,都返回true。 示例： console.log(!false); // true console.log(!\"\"); // true console.log(!\"blue\"); // false console.log(!0); // true console.log(!12345); // false console.log(!NaN); // true 3.1.2 逻辑与(&&) 1. 如果第一个操作数是对象或者两个操作数都是对象，都返回第二个操作数； 2. 如果有一个操作数是null，返回null; 如果有一个操作数是NaN，返回NaN; 如果有一个操作数是undefined，返回undefined; 如果有一个操作数是false，返回false. 3.1.3 逻辑或(||) 1. 如果第一个操作数是对象或者两个操作数都是对象，返回第一个操作数； 2. 如果第一个操作数的求值结果为false，则返回第二个操作数； 3. 如果有两个操作数是null，返回null; 如果有两个操作数是NaN，返回NaN; 如果有两个操作数是undefined，返回undefined; 如果有一个操作数是true，返回true. 3.2 相等操作符、赋值操作符 3.2.1 相等与不相等 == 和 != ： 1. 如果有一个操作数是布尔值，比较相等性前自动转换为数值，false转换为0，true转换为1； 2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等行之前自动将字符串转换为数值； 3. 如果一个操作数是对象，另一个操作数不是，自动调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较。 示例： null == undefined //true //就是true，记住就好了，哈哈 NaN == NaN //false //非数不等于非数 NaN != NaN //true false == 0;true == 1 //true //false转换后是0，true转换后是1 \"5\" == 5 //true //自动转换字符串为数值 3.2.2 全等与不全等 === 和 !==,▲全等仅限在两个操作数未经转换就相等的情况下返回true，不全等在两个操作数未经转换就不相等的情况下返回true。例如： \"55\" == 55; //true,因为转换后相等 \"55\" === 55; //false,因为不同的数据类型不相等 \"55\" != 55; //false,因为转换后相等 \"55\" !== 55; //true,因为不同的数据类型不相等 null == undefined; //true null === undefined; //false,因为他们是不同类型的值 PS:由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完善性，我们推荐使用全等和不全等操作符。 3.2.3 赋值操作符 var num = 10; var name = \"徐少\"； 3.3 条件操作符、逗号操作符 条件操作符： variable = boolean_expression ? true_value : false_value; 示例： var max = (num1 > num2) ? num1 : num2; //如果num1>num2，返回true，num1赋值给max;否则返回false，num2赋值给max。 逗号操作符： 用逗号操作符声明多个变量，在一条语句中执行多个操作；逗号操作符总是返回表达式中的最后一项。 var num1 = 1,num2 = 2,num3 = 3; //一条语句执行多个操作 var num = (5, 1, 0); //num的值为0 4.流控制语句 4.1 if语句 if (i > 25) { console.log(\"大于25\"); } else if (i 4.2 do-while语句，while语句 do-while语句 do { statement } while (expression); 示例： var i = 0; do { i += 2; } while (i while语句 while (expression) { statement } 示例： var i = 0; while (i 4.3 for语句 for (initialization; expression; post-loop-expression) { statement } 示例： var count = 10; var i = 0; for (; i 4.4 for-in语句 for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 for (property in expression){ statement } 示例： for (var propName in window) { document.write(); } //循环显示BOM中window对象的所有属性 如果要迭代的对象的变量值为null或undefined，for-in语句不会执行循环。使用for-in前先检测对象的值不是null或undefined。 4.5 break和continue语句 break跳出整个大循环，continue跳出当次循环后继续执行。 break示例： var num = 0; for (var i=1; i 4.6 switch语句 switch比较值时使用的是全等操作符，因此不会发生类型转换。（例如，\"10\"不等于10） switch (expression) { case value: statement break; case value: statement break; case value: statement break; default: statement } case的含义是：如果表达式等于这个值(value)，则执行后面的语句(statement); break关键字会导致代码执行流跳出switch; 省略break，执行完当前case后，就会继续执行下一个case; default: 表达式不匹配前面任何一种情形的时候，执行这里的代码。 示例： switch (num) { case 1: console.log(\"我是小明\"); break; case 2: console.log(\"我是小红\"); break; case 3: console.log(\"我是小东\"); break; default: console.log(\"你的数字不是1、2、3哟\"); } 4.7 label语句和with语句 label语句可以咋子代码中添加标签，以便将来使用：label:statement start: for(var i=0; i with语句：为了简化多次编写同一个对象的工作。【不建议使用with语句】 5.函数 function functionName(arg0) { statements } ES中任何函数定义时不必指出是否返回值，但后面随时可跟return语句返回值。函数执行完return后停止并立即退出，因此位于return之后的任何代码永远不会执行。 function sum(num1, num2) { return num1 + num2; } var result = sum(5, 10); 建议：要么让函数始终都返回一个值，要么永远都不要返回值，不然时而返回时而不返会给调试代码带来不便。 5.1 参数 (ES参数与其他语言有些不同，不介意传进来多少个或者什么数据类型，比如只传递两个参数，但可以调用任意个参数。)因为：ES中的参数在内部是用一个数组来表示的。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。 通过访问arguments对象的length属性可以获知传递了多少个参数： //开发人员利用这点让函数能够接受任意个参数并分别实现适当功能，这是一个不太完美的重载 function howMany() { console.log(arguments.length); } howMany(11, \"xushao\", abc); // 3 howMany(); // 0 arguments 对象可以与命名参数一起使用： function doAdd(num1, num2) { if(arguments.length == 1) { console.log(num1 + 10); } else if (arguments.length == 2) { console.log(arguments[0] + num2); } }//如果参数长度为1，执行第一个if；如果为2，执行else if。这里执行else if，这里的arguments[0] = num1. arguments的值永远与对应命名参数的值保持同步： function doAdd(num1, num2) { arguments[1] = 10; sum = arguments[0] + num2; console.log(sum); }//这里修改了arguments[1]也就是修改了num2。不过这里不是说读取这两个值都会访问相同的空间，他们的内存空间是独立的，但它们的值会同步。但这种影响是单向的，修改命名参数不会改变arguments的值。 //同时，如果只传入一个参数，那么为arguments[1]设置的值不会反应到命名参数中。因为arguments对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。 PS:ES中所有参数传递的都是值，不可能通过引用传递参数。 5.2 没有重载 ▲ES不能像传统意义上那样实现重载。但是可以通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:19:30 "},"part3/javascript_high_level/3.html":{"url":"part3/javascript_high_level/3.html","title":"3.变量、作用域、内存和引用类型","keywords":"","body":"1. 变量、作用域和内存问题 1、ES中所有函数的参数都是按值传递的，意思就是把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 function addTen(num) { num += 10; return num; } var count = 20; var result = addTen(count); alert(count); //20，没有变化 alert(result); //30 2、typeof检测变量是字符串、数值和布尔值还是undefined，如果是null和一个对象，返回object。 var s = \"shuai\"; var i = 22; var u; var n = null; var o = object(); console.log(typeof s); //string console.log(typeof i); //number console.log(typeof u); //undefined console.log(typeof n); //object console.log(typeof o); //object 3、执行环境和作用域： 1.Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法。 2.每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ES程序中的执行流正是由这个方便的机制控制着。 3.当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 4、没有块级作用域：在其他类C的语言中，由花括号封闭的代码块都有自己的作用域，但是JS并没有自己的块级作用域。 if语句中的变量声明会将变量添加到当前的执行环境中: if(true) { var color = \"blue\"; } console.log(color); //\"blue\" 切记使用for语句时的这一差异: for (var i=0; i 5、垃圾收集：JS程序内存回收实现了自动管理，自动释放内存。但是，系统分配给Web浏览器得到可用内存数量通常要比分配给桌面应用程序的少。（这是出于安全考虑，防止运行JS的网页耗尽全部系统内存而导致系统崩溃。） 所以，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式就是，为执行中的代码值保存必要的数据，一旦数据不会再使用到，最好将其值设置为null来释放它的引用——这就是“==解除引用==”。（这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动解除引用。）（解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。） Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:20:43 "},"part3/javascript_high_level/4.html":{"url":"part3/javascript_high_level/4.html","title":"4.Array","keywords":"","body":" 目录 1.延迟脚本和异步脚本 2.Array类型的方法 1.延迟脚本和异步脚本 延迟脚本：只适用于外部脚本文件，脚本会被延迟到整个页面都解析完毕后再运行。（相当于告诉浏览器立即下载，但延迟执行） 异步脚本：只适用于外部脚本文件，告诉浏览器立即下载文件，但是并不保证按照指定这些脚本的先后顺序执行。(建议异步脚本不要在加载期间修改DOM。) 2.Array类型的方法 方法 类别 功能 ▲ push() 栈方法 将参数添加到数组末尾 pop() 栈方法 移除数组末尾最后一项 shift() 队列方法 移除数组第一项 unshift() 队列方法 在数组前端添加项 reverse() 重排序方法 反转数组项顺序 sort() 重排序方法 从小到大排列数组，可接收比较函数作为参数 ▲ slice() 操作方法 接收数组起始和结束位置并返回相应的数组 splice() 操作方法 删除，插入，替换 indexOf() 位置方法 查找某项(值必须完全相等)在数组中的位置 以下方法接受两个参数，前五个方法参数是函数和作用域对象： 方法 类别 功能 every() 迭代方法 如果该函数对每一项都返回true，则返回true。 some() 迭代方法 如果该函数对某一项返回true，则返回true。 ▲ filter() 迭代方法 返回该函数会返回true的项组成的数组。 ▲ forEach() 迭代方法 对每一项执行某些操作，没有返回值。 ▲ map() 迭代方法 返回每次函数调用的结果组成的数组。 reduce() 归并方法 从头到尾逐个遍历，迭代数组中的所有项（见第7点） 1.栈方法：后进先出 push():接收任意数量的参数，将它们逐个添加到数组末尾，返回修改后的数组长度。 pop():从数组末尾移除最后一项，减少数组的length值，返回移除的项。 2.队列方法：先进先出 shift():移除数组第一项并返回该项，将数组长度减1。 unshift():在数组前端添加任意项并返回新数组的长度。 3.重排序方法 reverse():反转数组项的顺序。 sort():比较数组转型的字符串，从小到大排列。可以接收比较函数作为参数。 function compare(v1, v2) { if (v1 v2) { return 1; } else { return 0; } } var numArray = [11, 24, 55, 90, 67]; numArray.sort(compare); console.log(numArray); // 11,24,55,67,90 4.操作方法 slice():接收一个或两个参数，即返回项的起始和结束位置。不会影响原始数组。 var num = [1, 2, 3, 4, 5]; var numFind_1 = num.slice(1); var numFind_2 = num.slice(1,4); console.log(numFind_1); // 2, 3, 4, 5 返回从指定位置开始到数组末尾所有项。 console.log(numFind_2); // 2, 3, 4 返回从指定位置开始到指定结束项。 splice():接收多个参数。 删除：删除任意数量的项，指定前两个参数，删除的第一项的位置和要删除的项数。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(0,3); // 删除第一项开始的前三项 console.log(numArray); // 90, 67 插入：插入任意数量的项，起始位置，0(删除的项数)，以及插入的项。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(1, 0, 88); // 在第二项的位置插入88 console.log(numArray); // 11, 88, 24, 55, 90, 67 替换：指定位置，删除某项，插入替换项。 var numArray = [11, 24, 55, 90, 67]; numArray.splice(1, 1, 88); // 先删除第二项，再在第二项的位置插入88 console.log(numArray); // 11, 88, 55, 90, 67 5.位置方法 indexOf():返回查找的项在数组中的位置，但是查找的项的值必选严格相等。 var numArray = [11, 24, 55, 90, 67]; console.log(numArray.indexOf(90)); // 3，表示90为数组中第三位，第四项 6.迭代方法： 1.每个迭代方法都会接收两个参数：要在==数组中的每一项==都运行的函数和（可选的）运行该函数的作用域对象-影响this的值。 2.传入这些方法中的函数会接收三个参数：数组某项的值(item)，该项在数组中的位置(index)，数组对象本身(array)。 every():如果该函数对每一项都返回true，则返回true。 some():如果该函数对某一项返回true，则返回true。 filter():返回该函数会返回true的项组成的数组。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var everyResult = numArray.every(function(item, index, array){ return (item > 3); }); console.log(everyResult); // false var someResult = numArray.some(function(item, index, array){ return (item > 3); }); console.log(someResult); // true var filterResult = numArray.filter(function(item, index, array){ return (item > 3); }); console.log(filterResult); // [4, 5, 6, 7] forEach():对每一项执行某些操作，没有返回值。 map():返回每次函数调用的结果组成的数组。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var a = numArray.map( function(item, index, array) { return item + 10; }); console.log(a); // [11, 12, 13, 14, 15, 16, 17] numArray.forEach(function(item, index, array) { // 执行某些操作 }); 7.归并方法 reduce():从头到尾逐个遍历，迭代数组中的所有项，然后构建一个最终返回的值。 1.接收两个参数：一个在每一项上调用的函数和(可选的)作为归并基础的初始值。 2.传入的函数接收四个参数：前一个值(prev)，当前值(cur)，项的索引(index)，数组对象(array)。这个函数返回的任何值都会作为第一个参数自动传给下一项。 var numArray = [1, 2, 3, 4, 5, 6, 7]; var sum = numArray.reduce(function(prev, cur, index, array){ return prev + cur; }); console.log(sum); // 28 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:20:24 "},"part3/javascript_high_level/5.html":{"url":"part3/javascript_high_level/5.html","title":"5.Date Function Global Math","keywords":"","body":" 目录 1.Date()类型的组件方法 2.Function类型 2.1 函数声明与函数表达式 2.2 作为值的函数 2.3 函数内部属性 2.4 函数属性和方法 3.单体内置对象 3.1 Global对象 3.2 Math对象 1.Date()类型的组件方法 Date()方法使用实例: var myTime = new Date(); console.log(myTime.toLocaleString()); // 2017/10/7 下午4:52:53 日期/时间组件方法： 方法 说明 getFullYear() 取得四位数的年份 getMonth() 返回日期中的月份，0表示一月，11表示12月 getDate() 返回日期月份中的天数 getDay() 返回日期中星期几，0表示星期日，6表示星期六 getHours() 返回日期中的小时数(0-23) getMinutes() 返回日期中的分钟数(0-59) getSeconds() 返回日期中的秒数(0-59) getMilliseconds() 返回日期中的毫秒数 ▲ toLocaleDateString() 获取当前日期 ▲ toLocaleTimeString() 获取当前时间 ▲ toLocaleString() 获取当前日期与时间 2.Function类型 2.1 函数声明与函数表达式 函数声明提升：解析器向执行环境加在数据的时候，对函数声明和函数表达式并非一视同仁。==解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。== 2.2 作为值的函数 函数名本身就是变量，所以函数也可以作为值来使用。 根据对象数组某个属性排序： function createComparisonFunction(propertyName) { return function(object1, object2){ var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 value2) { return 1; } else { return 0; } }; } // 使用上面的函数createComparisonFunction var data = [ {name:\"ZhouShao\", age:25 }, {name:\"XuShuai\", age:20 }, {name:\"CaiShao\", age:22 } ]; data.sort(createComparisonFunction(\"name\")); console.log(data); // CaiShao...XuShuai...ZhouShao... data.sort(createComparisonFunction(\"age\")); console.log(data); // XuShuai...CaiShao...ZhouShao... 2.3 函数内部属性 虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。 阶乘函数例子： function factorial(number){ if (number this引用的是函数 据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。 2.4 函数属性和方法 ▲ 每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。对于ES中的引用类型而言，prototype是保存它们所有实例方法的真正所在。 ▲ 每个函数都包含两个非继承而来的方法：apply()和call()。它们的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。 apply()方法：接收两个参数，第一个是在其中运行函数的作用域，另一个是参数数组(第二个参数可以是Array实例，也可以是arguments对象)。 function sum(a, b){ return a + b; } function callSum1(a, b){ return sum.apply(this, arguments); // 传入arguments对象 } function callSum2(a, b){ return sum.apply(this, [a, b]); // 传入数组 } console.log(callSum1(5, 6)); // 11 console.log(callSum2(5, 6)); // 11 call()方法：第一个参数是this值，其余参数都直接传递给函数。 function sum(a, b){ return a + b; } function callSum(a, b){ return sum.call(this, a, b); // 传入arguments对象 } console.log(callSum(6, 7)); // 13 ▲ apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域。使用call()扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。 var color = 'purple'; var o = { color : \"yellow\" }; function sayColor(){ console.log(this.color); } sayColor(); // purple sayColor.call(this); // purple sayColor.call(window); // purple sayColor.call(o); // yellow ES5还定义了bind()方法，它会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。 var color = 'purple'; var o = { color : \"yellow\" }; function sayColor(){ console.log(this.color); } var say = sayColor.bind(o); // 把o对象传入给saycolor()并创建了say()函数，所以say()函数的this值等于o。 say(); // yellow 3.单体内置对象 3.1 Global对象 事实上，全局变量或全局函数——所有在全局作用域中定义的属性和函数，都是Global对象的属性。 encodeURI()和encodeURIComponent()方法：前者将空格转码为20%，后者将所有非字母数字字符转码为20%。(一般使用后者使用更多)。可以分别使用decodeURI()和decodeURIComponent()进行解码。 var uri = \"http://www.baidu.com/illegal value.html#start\"; // http://www.baidu.com/illegal%20value.html#start console.log(encodeURI(uri)); // http%3A%2F%2Fwww.baidu.com%2Fillegal%20value.html%23start console.log(encodeURIComponent(uri)); -eval()方法：只接受一个参数——ES或JS要执行的字符串。 eval(\"console.log('123')\"); // '123' 3.2 Math对象 方法 作用 Math.max() 取得最大值 Math.min() 取得最小值 Math.ceil() 执行向上舍入 Math.floor() 执行向下舍入 Math.round() 执行标准舍入 ▲ Math.random() 返回大于等于0小于1的随机数 补充：如何向Math.max()/Math.min()传入数组： var arr = [1, 2, 3, 4, 5]; var max = Math.max.apply(Math, arr); // 确定一个数组中的最大值 ES6的写法 Math.max(...arr); 补充：如何返回某个区间的随机数，Math.random(): 整数值 = Math.floor(Manth.random() * 可能值的总数 + 第一个可能的值)。 // 选择一个介于 2 到 10 之间整数书值。 var num = Math.floor(Math.random() * 9 + 2); // 2~10 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:21:09 "},"part3/javascript_high_level/6.html":{"url":"part3/javascript_high_level/6.html","title":"6.对象设计","keywords":"","body":" 目录 1.面向对象的程序设计 1.1 创建对象 1.2 继承 1.面向对象的程序设计 1.1 创建对象 六种模式：工厂模式、构造函数模式、原型模式、动态原型模式、寄生构造函数模式、稳妥构造函数模式。 ▲ 创建对象的最佳方式是组合使用构造函数模式和原型模式，使用构造函数定义实例属性，而使用原型模式定义共享的属性和方法。 组合使用构造函数模式和原型模式： 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。这样的话，不仅支持向构造函数传递参数，而且每个实例都会有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度地节省了内存。 // 构造函数模式用于定义实例属性 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = [\"XiangShuai\", \"ZhanShen\"]; } // 原型模式用于定义方法和共享的属性 Person.prototype = { // 默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性是一个指向prototype属性所在函数的指针 // 这里的Person.prototype.constructor指向Person constructor : Person, sayName : function() { console.log(this.name); } } var person1 = new Person(\"Kalen\", 30, \"Software Engineer\"); var person2 = new Person(\"Xushao\", 21, \"Doctor\"); person1.friends.push(\"Xushao\"); console.log(person1.friends); // [\"XiangShuai\", \"ZhanShen\", \"Xushao\"] console.log(person2.friends); // [\"XiangShuai\", \"ZhanShen\"] console.log(person1.friends === person2.friends); // false console.log(person1.sayName === person2.sayName); // true 1.2 继承 六种方式：原型链、借用构造函数、组合继承、原型式继承、寄生式继承、寄生组合式继承。 ▲ 组合继承：这种模式使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 function SuperType(name) { this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function() { console.log(\"name:\" + this.name); }; function SubType(name, age) { // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(\"age:\" + this.age); }; // 这样定义的话，可以让两个不同的SubType既分别拥有自己的属性，又可以使用相同的方法了。 var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); console.log(\"instance1.colors:\" + instance1.colors); // instance1.colors:red,blue,green,black instance1.sayName(); // name:Nicholas instance1.sayAge(); // age:29 var instance2 = new SubType(\"Greg\", 22); console.log(\"instance2.colors:\" + instance2.colors); // instance2.colors:red,blue,green instance2.sayName(); // name:Greg instance2.sayAge(); // age:22 ▲ object.create(): // 实现继承 var extend = function(Child, Parent) { // 拷贝Parent原型对象 Child.prototype = Object.create(Parent.prototype); // 将Child构造函数赋值给Child的原型对象 Child.prototype.constructor = Child; } // 实例 var Parent = function () { this.name = 'Parent'; } Parent.prototype.getName = function () { return this.name; } var Child = function () { Parent.call(this); // call super constructor. } extend(Child, Parent); var child = new Child(); console.log(child.getName()) Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:05:01 "},"part3/javascript_high_level/7.html":{"url":"part3/javascript_high_level/7.html","title":"7.闭包","keywords":"","body":" 目录 1.函数表达式 1.1 递归 ▲▲▲1.2 闭包 1.2.1 闭包与变量 1.2.2 关于this对象 1.2.3 内存泄漏 ▲ 1.3 模仿块级作用域 1.4 私有变量 > 1.4.1 静态私有变量 1.函数表达式 定义函数的方式有两种：一种是函数声明，另一种是函数表达式。 关于函数声明，它的一个重要特征就是函数声明提升，在执行代码之前会先读取函数声明，这意味着可以把函数声明放在调用它的语句后面。 sayHi(); function sayHi() { console.log(\"Hi!\"); }; 关于函数表达式，创建一个函数将它赋值给某个变量，这种情况下创建的函数叫做==匿名函数==。 var functionName = function (arg0, arg1) { // 函数主体 }; 1.1 递归 递归是一个函数通过名字调用自身情况下构成的。 arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，同时它可以实现递归调用时的松耦合。 function factorial(num) { if (num ▲▲▲ 1.2 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。（所以创建闭包的常见方式，就是在一个函数内部创建另一个函数。） 一般的函数调用执行：当某个函数被调用时，会创建一个执行环境以及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。后台的每个执行环境都有一个变量对象（全局环境的变量对象始终存在，而局部环境的变量对象则只在函数执行的过程中存在）。所以，==无论什么时候在函数中访问一个变量，都会从作用域链中搜索具有相应名字的变量。一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)==。 function compare(value1, value2) { if (value1 value2) { return 1; } else { return 0; } } var result = compare(5, 10); 以上代码先定义了compare()函数，然后在全局作用域中调用了它。 在调用时，会创建一个包含arguments、value1和value2的活动对象。 就compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。 ▲ 闭包的执行调用：在函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。外部函数执行完毕后，它的活动对象也不会被销毁，因为内部内部函数的作用域链仍然在引用这个活动对象(换句话说，当外部函数返回之后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到内部函数被销毁后，外部函数的活动对象才会被销毁——比如手工解除对内部函数的引用)。【所以，由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包可能会导致内存占用过多，所以要慎重使用闭包】。 1.2.1 闭包与变量 闭包只能取得包含函数中任何变量的最后一个值，闭包所保存的是整个变量对象，而不是某个特殊的变量。 例如： function createFunction () { var result = new Array(); for (var i = 0; i 1.2.2 关于this对象 匿名函数的执行环境有全局性，其this对象通常指向window。不过，==每个函数在被调用时都会自动取得两个特殊变量：this和arguments。== 在闭包中调用this对象和arguments时，把外部作用域中的this对象和arguments保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。 var name = \"XuShao\"; var obj = { name : \"XiangShuai\", // 一般函数引用 getName : function(){ return this.name; }, // 闭包调用时，不转换this对象 getNameFunc1 : function () { return function () { return this.name; }; }, // 闭包调用时，转换this对象 getNameFunc2 : function () { // 定义匿名函数之前，把this对象值赋给that对象，这样定义闭包后，闭包也可以访问这个变量了 var that = this; return function () { return that.name; }; } }; console.log(obj.getName()); // \"XiangShuai\" console.log(obj.getNameFunc1()()); // \"XuShao\" console.log(obj.getNameFunc2()()); // \"XiangShuai\" 1.2.3 内存泄漏 如果闭包的作用域链保存了一个HTML元素，那么该元素无法被销毁。 点击我 function assignHandler() { var element = document.getElementById(\"someElement\"); // element.onclick = function () { // console.log(element.id); // }; // 我们使用垃圾回收机制接触引用让值脱离执行环境，以便垃圾收集器下次回收，确保正常回收其占用的内存。 // 把element.id的一个副本保存在一个变量中，在闭包中引用该变量消除了循环引用。 var id = element.id; element.onclick = function () { console.log(id); } // 闭包会引用包含函数的整个活动对象，其中会至少保存一个引用，所以这里有必要把element设置为null,解除对DOM对象的引用。 element = null; } assignHandler(); ▲ 1.3 模仿块级作用域 JS没有块级作用域的概念，但是可以用匿名函数来模仿块级作用域(也称私人作用域)。 例：立即执行的匿名函数 (function () { // 这里是块级作用域 })(); // 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。 只是临时需要一些变量，就可以使用私有作用域，在匿名函数中定义的任何变量，都会在执行结束时被销毁： var len = 5; function outputNumber(count) { (function () { for (var i = 0; i 推荐使用该技术，一方面可以避免过多的全局变量和函数命名冲突，不必担心搞乱全局作用域；另一方面这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链了。 (function () { var now = new Date(); if (now.getMonth() == 0 && now.getDate() == 1) { console.log(\"Happy new year!\"); } })(); 1.4 私有变量 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。 有权访问私有变量和私有函数的公有方法称为==特权方法==。有两种在对象上创建特权方法的方式。一种是在构造函数中定义特权方法，但构造函数模式的缺点是针对每个实例都会创建同样一组新方法，所以使用==静态私有变量==实现特权方法就可以避免这个问题。 1.4.1 静态私有变量 在私有作用域(块级作用域)中定义私有变量或函数可以创建特权方法： (function () { // 变量name是一个静态的、由所有实例共享的属性。 var name = \"\"; // 初始化未经声明的变量，总是会创建一个全局变量。 // 所以Person就成了一个全局变量，能够在私有作用域之外被访问到。 Person = function (value) { name = value; }; Person.prototype.getName = function () { return name; }; Person.prototype.setName = function (value) { name = value; }; })(); var person1 = new Person(\"Nicholas\"); console.log(person1.getName()); // \"Nicholas\" person1.setName(\"Greg\"); console.log(person1.getName()); // \"Greg\" // 调用setName()或新建一个Person实例都会赋予name属性一个新值 var person2 = new Person(\"XuShao\"); console.log(person1.getName()); // \"XuShao\" console.log(person2.getName()); // \"XuShao\" person1.setName(\"Greg\"); console.log(person1.getName()); // \"Greg\" console.log(person2.getName()); // \"Greg\" 附：多查找作用域链中的一个层次，就会在一定程度上影响查找速度。这正是使用闭包和私有变量的一个不足之处。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:22:21 "},"part3/javascript_high_level/8.html":{"url":"part3/javascript_high_level/8.html","title":"8.window location 间歇和超时","keywords":"","body":" 目录 window对象 > 1.1 屏幕/浏览器/元素宽高 1.2 导航和打开窗口 1.3 系统对话框 间歇调用和超时调用 location对象 > 3.1 位置操作 1.window对象 浏览器中，window对象既是通过JS访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。 定义全局变量和在window对象上定义属性的一点差别：全局变量不能通过delete操作符删除，但window对象上定义的属性可以。 var age = 29; window.color = \"red\"; delete window.age; // 无效 delete window.color; // 删除 console.log(window.age); // 29 console.log(window.color); // undefined 1.1 屏幕/浏览器/元素宽高 console.log(document.body.clientWidth); //网页可见区域宽(body) console.log(document.body.clientHeight); //网页可见区域高(body) console.log(document.body.offsetWidth); //网页可见区域宽(body)，包括border、margin等 console.log(document.body.offsetHeight); //网页可见区域宽(body)，包括border、margin等 console.log(document.body.scrollWidth); //网页正文全文宽，包括有滚动条时的未见区域 console.log(document.body.scrollHeight); //网页正文全文高，包括有滚动条时的未见区域 console.log(document.body.scrollTop); //网页被卷去的Top(滚动条) console.log(document.body.scrollLeft); //网页被卷去的Left(滚动条) console.log(window.screenTop); //浏览器距离Top console.log(window.screenLeft); //浏览器距离Left console.log(window.screen.height); //屏幕分辨率的高 console.log(window.screen.width); //屏幕分辨率的宽 console.log(window.screen.availHeight); //屏幕可用工作区的高 console.log(window.screen.availWidth); //屏幕可用工作区的宽 1.2 导航和打开窗口 使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法接收四个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值(通常只传递一个参数，最后一个参数只在不打开新窗口的情况下使用)。 (function(){ var xixi = document.getElementById(\"xixi\"); xixi.onclick = function(){ // 新的页面打开百度链接 window.open(\"https:www.baidu.com\",\"_blank\"); } })(); 1.3 系统对话框 浏览器通过alert()、confirm()、prompt()方法可以调用系统对话框向用户显示消息。通过这几个方法打开的对话框都是同步和模态的(也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又恢复执行)。 2.间歇调用和超时调用 ==超时调用==：使用window对象的setTimeout()方法，它接收两个参数，第一个参数一般是函数，第二个参数是以毫秒表示的时间。 如果要取消尚未执行的超时调用，使用clearTimeout()方法并将相应的超时调用ID作为参数传递给它。 // 不推荐第一个参数使用字符串，会导致性能损失，推荐的调用方式如下： var timeoutId = setTimeout(function() { console.log(\"123\"); }, 1000) clearTimeout(timeoutId); // 取消超时调用 ==间歇调用==：按照指定时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval(),接收的参数是要执行的函数和每次执行前需要等待的毫秒数。 // 每隔5秒输出 setInterval(function() { console.log(\"123\"); }, 1000) 注：在使用超时调用时，没必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境中，很少使用真正的间歇调用，原因是一个间歇调用可能会在前一个间歇调用结束之前启动。所以像下面这样使用超时调用，则完全可以避免这一点： vfunction incrementNumber() { num++; // 如果执行次数未达到max的值，则设置另一次超时调用 if (num 3.location对象 location对象很特别，它既是window对象的属性，也是document对象的属性。换句话说：window.location和document.location引用的是同一个对象。 常用location对象属性： 属性名 | 说明 ---|--- hash | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 search | 返回URL中的查询字符串，这个字符串以问号开头 hostname | 返回不带端口号的服务器名称 pathname | 返回URL中的目录或文件名 port | 返回URL中指定的端口号，如果URL中不包含端口号，则这个属性返回空字符串 3.1 位置操作 改变浏览器位置的方法： 法一： window.location = \"https://www.baidu.com\"; 法二： location.href = \"https://www.baidu.com\"; 通过hash、search、hostname、pathname和port修改URL： // 假设初始值为\"https://www.baidu.com\", 每次修改location页面都会以新URL重新加载 // 将URL修改为\"https://www.baidu.com/#section\" loction.hash = \"#section\"; // 将URL修改为\"https://www.baidu.com/?name=xuqingfeng\" location.search = \"?name=xuqingfeng\"; // 将URL修改为\"https://www.taobao.com\" location.hostname = \"www.taobao.com\"; // 将URL修改为\"https://www.taobao.com/myId\" location.pathname = \"myId\"; // 将URL修改为\"https://www.taobao.com:8080/myId\" location.port = \"8080\"; reload()重新加载当前显示页面。位于reload()后的代码可能不会执行，最好是将reload()放在最后一行 location.reload(); // 重新加载，可能从缓存中加载 location.reload(true); // 重新加载，从服务器重新加载 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-01 16:22:46 "},"part3/maintainable_js/1.html":{"url":"part3/maintainable_js/1.html","title":"1.基本格式、注释、语句和表达式、变量函数运算符","keywords":"","body":"1.代码的一些基本格式 1.缩进 1.1使用制表符缩进（通常一个长度相当于四个字符） 1.2使用空格符进行缩进（一般是四个空格的缩进，tab快捷键） 2.语句结尾 javascript要么独占一行，要么以分号结尾。 分析器有自动分号插入（ASI）机制，但ASI分号插入规则复杂且难记，所以语句结尾不要省略分号。 3.行的长度 一般javascript一行长度限定在80个字符。 4.换行 //推荐做法：在运算符后换行，第二行追加两个缩进 callAFunction(document,element,window,\"some string value\",true,123, navigator); //不好的做法：第二行只有一个缩进 callAFunction(document,element,window,\"some string value\",true,123, navigator); //不好的做法：运算符之前换行 callAFunction(document,element,window,\"some string value\",true, 123 ,navigator); 例外：当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐。 var result = something + anotherThing + yetAnotherThing + somethingElse + anotherSomethingElse; 空行 推荐在每个流控制语句之前（比如if和for语句）添加空行。这样做能是你更流畅地阅读这些语句。一般在下列场景添加空行: 在方法之间; 在方法中的局部变量和第一条语句之间; 在多行或单行注释之前; 在方法内的逻辑片段之间插入空行，提高可读性. ▲6.命名 推荐：驼峰式命名 6.1变量和函数 以名词作为前缀可以让变量和函数区分开来，因为函数名前缀应当是动词。 //好的写法 var count = 10; var myName = \"Nicholas\"; var found = true; //不好的写法:变量看起来像函数 var getCount = 10; var isFound = true; //好的写法 function getName() { return myName; } //不好的写法：函数看起来像变量 function theName() { return myName; } 命名长度尽量短，抓住要点，尽量在变量名中体现出值的数据类型。比如： 命名 count、length、size表明数据类型是数字； 命名 name、title、message表明数据类型是字符串； 用单个字符命名的变量诸如i、j、k通常在玄幻中使用。 对于函数和方法命名来说，第一个单词应该是动词，这里有一些使用动词常见的约定。 单词 | 含义 ---|--- can | 函数返回一个布尔值 has | 函数返回一个布尔值 is | 函数返回一个布尔值 get | 函数返回一个非布尔值 set | 函数用来保存一个值 例如： if (isEnabled()) { setName(\"Nicholas\"); } if (getName() === \"Nicholas\") { doSomething(); } 6.2常量 为了区分普通的变量（变量的值是可变的）和常量（常量的初始化之后就不能变了），一种通用的命名约定应运而生。这个约定源自于C语言，它使用大写字母和下划线来命名，下划线用以分隔单词。例如： var MAX_COUNT =10;//这是一个被定义的最好是不要更改的常量 var URL = \"http://www.baidu.com/\";//这是一个被定义的最好不要更改的常量 var count;//这是一个被定义的可以更改的变量 6.3构造函数 在JS中，构造函数只不过是前面需要冠以new运算符的函数，用来创建对象。构造函数的命名遵照大驼峰命名法。这样做可以将构造函数从变量和普通函数中区分出来。 //好的做法 function Person(name) { this.name = name; } Person.prototype.sayName = function() { alert(this.name); } var me = new Person(\"Nicholas\"); 7.直接量 7.1字符串：推荐使用双引号括起，多行字符串的替代写法是，使用字符串连接符（+）将字符串分成多份。 //好的写法 var name = \"Nicholas says, \\\"Hi.\\\"\"; //Good var longString = \"Here is the story, of a man \" + \"named Brady.\"; 7.2数字：使用十进制。 ▲7.3null与undefined 在下列场景中应当使用null 用来初始化一个变量，这个变量可能赋值为一个对象； 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象； 当函数的参数期望是对象时，用作参数传入； 当函数的返回值期望是对象时，用作返回值传出。 例如： var person = null; function getPerson() { if (condition) { return new Person(\"Nicholas\"); } else { return null; } } var person = getPerson();//已经初始化的变量，也可以不是对象 if (person !== null) { doSomething(); } 在下列场景中不要使用null 不要用null来检测是否传入了某个参数。 不要用null来检测一个未初始化的变量。 例如： var person;//用来和未初始化的变量比较。 if (person != null) { doSomething(); } function doSomething(arg1, arg2, arg3, arg4) { if (arg4 != null) { doSomethingElse(); } } 关于undefined： (有一个令人困惑的地方就是：null == undefined 结果是true) //一种非常不好的写法 var person; console.log(person === undefined);//true 尽管这段代码能正常工作，但我建议避免在代码中使用undefined。 这个值常常和返回“undefined”的typeof运算符混淆。 事实上，不管值是undefined的变量或者未声明的变量，typeof的运算结果都是“undefined”。比如： //foo未被声明 var person; console.log(typeof person);//\"undefined\" console.log(typeof foo);//\"undefined\" 通过禁止使用特殊只undefined，可以有效地确保只在一种情况下typeof才回返回“undefined”：当变量未声明时。 如果你使用了一个可能（或可能不会）赋值为一个对象的变量时，则将其赋值为null。 ▲▲//好的做法 var person = null; console.log(person === null); //true 将变量初始值赋值为null表明这个变量的意图，它最终很可能赋值为对象。typeof运算符运算null的类型时返回“object”，这样就可以和undefined区分开了。 7.4 对象直接量 当定义对象直接量时，常常在第一行包含左花括号，每一个属性的名值对都独占一行，并保持一个缩进，最后右花括号也独占一行，比如： //好的写法 var book = { title: \"Maintainable JavaScript\", author: \"Nicholas C. Zakas\" } //不好的写法 var book = new object(); book.title = \"Maintainable JavaScript\"; book.author = \"Nicholas C. Zakas\"; 7.5 数组直接量 不赞成显式地使用Array构造函数来创建数组，可以使用两个方括号将数组处事元素括起来，来代替Array构造函数的方式来创建数组。 //不好的写法 var colors = new Array(\"red\", \"green\", \"blue\"); var numbers = new Array(1, 2, 3, 4); ▲▲//好的做法 var colors = [\"red\", \"green\", \"blue\"]; var numbers = [1, 2, 3, 4 ]; 2.注释 用处：1.难于理解的代码；2.可能被误认为错误的代码；(3.浏览器特性hack；4.文档注释。) 单行注释 1.代码尾部的注释，结束到注释之间有一个缩进，尾部注释不应超过最大字符数限制，如果超过就将这条注释放置于当前代码行的上方。 2.独占一行的注释，和之前的代码之间有一个空行，缩进层级和下一行代码保持一致。 //好的写法 if (condition) { // 如果代码执行到这里， 则表明通过了所有安全性检查。 allowed(); } 多行注释 //好的写法 if (condition) { /* * 如果代码执行到这里 * 说明通过了所有的安全性检测 */ allowed(); } 3.语句和表达式 使用花括号，并与语句对齐。块语句间隔，在括左圆括号之前和右圆括号之后各添加一个空格。 if (condition) { doSomething(); } else { doSomethingElse(); } switch语句：不要省略default，如果省略最好写一行注释。缩进不要太乱，好的写法如下： switch(condition) { case \"first\": // 代码 break; case \"second\": // 代码 break; case \"third\": // 代码 break; } 3.for循环和for-in循环 for循环 return,throw;break,continue四种方法都可以更改循环执行过程。 但尽可能避免使用continue，与其使用continue不如使用条件语句。 var values = [1, 2, 3, 4, 5, 6, 7], i, len; for (var i=0, len=values.length; i for-in循环 for-in循环不仅遍历对象的实例属性，同样还遍历从原型继承来的属性。当遍历自定义对象的属性时，往往会因为意外的结果而终止。 所以推荐总是使用hasOwnProperty()方法来过滤出实例属性。（除非你想查找原型链，这时补充注释：//包含对原型链的遍历） var prop; for (prop in object) { if (object.hasOwnProperty(prop)) { console.log(\"Property name is \" + prop); console.log(\"Property value is \" + object[prop]); } } 4.变量，函数，运算符 4.1变量 所有var语句都会提前到包含这段逻辑的函数的顶部执行。 function doSomething() { var result = 10 + value; var value = 10; return result; }//结果返回NaN 因为上面这段代码被JavaScript解析为如下模样： function doSomething() { var result; var value; result = 10 + value; value = 10; return result; } 两个var语句提前到函数顶部，初始化逻辑紧跟其后。先用到value的时候它是一个特殊值undefined，因此result的值就是NaN。（在之后value才被赋值为10） ▲最好将所有变量声明放在函数顶部而不是散落在各个角落： （▲推荐使用单var语句：保持成本最低，推荐合并var语句，可以让代码更短、下载更快。） // 好的写法 function doSomethingWithItems(items) { var value = 10, result = value + 10, i, len; for (i=0, len=items.length; i 4.2 函数声明和立即调用函数 函数声明：先声明JS函数然后再调用函数；同时函数的声明在语句外部，不应出现在语句块之内（比如两个函数被包括在if...else之内，那样的话大多数浏览器都会自动使用第二个声明。）。 立即调用函数 允许声明匿名函数（本身没有命名的函数），并将匿名函数赋值给变量或者属性。 ▲为了让立即执行函数能够被一眼看出来，可以将函数用一对圆括号包裹起来。 //好的写法 var value = (function() { //函数体 return { message: \"Hi\" } }()); 4.3 严格模式 不推荐将\"use strict\"用在全局作用域中，因为这会让文件中的所有代码都以严格模式来解析。 4.4 相等 ▲由于\"= =\"和\"!=\"涉及到强制类型转换，所以我们推荐不要使用\"= =\"和\"!=\"，而是应当使用= = =和! = =，用这些运算符作比较不会涉及强制类型转换。 4.5 eval() （eval()的参数是一个字符串，eval()会将传入的字符串当作代码来执行。通常和JSON操作有关。） 一个通用原则：严禁使用Function，并且只在别无他法时使用eval()，不过涉及到回调中解析JSON的时候，或者只允许将Ajax的返回值转换为JS值的时候允许使用eval()。 setTimeout()和setInterval()也是可以使用的，但不要用字符串形式而要用函数。 //好的写法 setTimeout(function() { document.body.style.background='red'; }, 50); setInterval(function() { document.title = 'It is now ' + (new Date()); }, 1000); //不好的写法,单纯地引入字符串形式 var myfunc = new Function(\"alert('Hi!')\"); setTimeout(\"document.body.style.background='red'\", 50); setInterval(\"document.title = 'It is now '\" + (new Date()), 1000); 4.6原始包装类型 JS有三种原始包装类型：String、Boolean、Number。原始包装类型的主要作用是让原始值具有对象般的行为。 //尽管name是一个字符串，是原始类型不是对象，但你仍然可以使用诸如toUpperCase()之类的方法，即将字符串当作对象来对待。 var name = \"Xushao\"; console.log(name.toUpperCase()); 避免使用包装类型，扰乱开发者思路增加出bug的概率 //不好的做法 var name = new String(\"Xushao\"); var author = new Boolean(true); var count = new Number(10); Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:13:16 "},"part3/maintainable_js/2.html":{"url":"part3/maintainable_js/2.html","title":"2.编程实践","keywords":"","body":"写在前头：本章笔记笔者只摘录总结了UI层的松耦合、避免使用全局变量、事件处理、避免“空比较”四个板块的笔记。 1. UI层的松耦合 Web开发： HTML用来定义页面的数据和语义； CSS用来给页面添加样式，创建视觉特征； JavaScript用来给页面添加行为，使其更具交互性。 UI层次关系：HTML在最底层，CSS和JavaScript在最高层。 1.1什么是松耦合 解决紧耦合问题就是松耦合，如果两个组件耦合太紧，说明一个组件和另一个组件直接相关。==当你能够做到修改一个组件而不需要更改其他的组件就能达成目标时，就做到了松耦合==。松耦合对于代码可维护性来说至关重要——开发人员在修改某部分代码时不会破坏其他人的代码。当一个大系统的每个组件的内容有了限制，就做到了松耦合。因此，我们的目标就是==确保对一个组件的修改不会经常性地影响其他部分==。 效果：如果做到了松耦合，代码就很容易调试。和文本或结构相关的问题，通过查找HTML定位；当发生了样式问题，查找CSS；与行为相关的问题，直接去JavaScript找到问题所在。这种能力是Web界面的可维护性的核心部分。 1.2 JavaScript、CSS、HTML互相独立 1.2.1 将JavaScript从CSS中抽离 切记不要在CSS中插入JS： /*非常不好的写法*/ .box{ width: expression(document.body.offsetWidth + \"px\"); }//设置元素宽度匹配浏览器宽度，其实是非常不好的写法 1.2.2 将CSS从JavaScript中抽离 将CSS样式写在JS中是一种很不好发现CSS问题的方式（如果你的CSS出现问题，你会精疲力竭地去排除CSS问题，再去查找JS样式信息，很不利于维护代码。） // 不好的写法之一 element.style.color = \"red\"; element.style.left = \"10px\"; element.style.visibility = \"visible\"; // 不好的写法之二 element.style.cssText = \"color: red; left: 10px; top: 100px; visibility: hidden\"; 这两种写法都很不利于CSS的代码维护，但是我们可以在CSS书写CSS样式，通过JS调用className来操作CSS样式： ▲一种好的写法，先写CSS样式 .reveal { color: red; left: 10px; top: 100px; visibility: visible; } ▲再写JS调用该CSS样式 // 好的写法 - 原生方法 element.className += \" reveal\"; // 好的写法 - HTML5 element.classList.add(\"reveal\"); // 好的写法 - YUI Y.one(element).addClass(\"reveal\"); // 好的写法 - jQuery $(element).addClass(\"reveal\"); // 好的写法 - Dojo dojo.addClass(element, \"reveal\"); （有一种情况可以使用style属性：当你需要给页面中的某个元素定位计算，style.top/left/bottom/right可以对元素正确定位。CSS中定义这个元素的默认属性，在JS中修改这些默认值。） 1.2.3 将JavaScript从HTML中抽离 最好将所有的JavaScript代码都放入外置文件中，确保HTML中没有内联的JavaScript代码，否则在调试时可能会阻断你的工作流，给你的调试造成不可预知的困扰，可预见性（\"Predictability\"）会带来更快的调试和开发。 下面是一个内联外联的实例： Click Me 2000年很多人采用这种写法，但问题是点击这里可能函数不存在，会造成JS报错；同时，可维护性差，紧耦合代码需要修改HTML和JS两方面的函数。 //对于支持2级DOM模型的浏览器来说，可以用下面的代码完成上面例子的功能 function doSomething() { // 代码 } var btn = document.getElementById('action-btn'); btn.addEventListener(\"click\", doSomething, false); 这个函数的优势在于，doSomething()的定义和事件处理程序的绑定都是在一个文件中完成的。 // IE8及其更早的版本不支持addEventListener()函数，因此你需要一个标准的函数将这些差异性封装 function addListener(target, type, handler) { // target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。 if (target.addEventListener) { target.addEventListener(type, handler, false); } else if (target.attachEvent) { target.attachEvent(\"on\" + type, handler); } else { target[\"on\" + type] = handler; } } 这个函数可以做到在各种浏览器中给一个元素添加事件处理程序，甚至可以降级到只支持0级DOM模型对象的on属性赋值处理程序。 // 我们常常像下面这样调用这个方法 function doSomething() { // 代码 } var btn = document.getElementById(\"action-btn\"); addListener(btn, \"click\", doSomething); // JS类库 - YUI调用 Y.one(\"#action-btn\").on(\"click\", doSomething); // JS类库 - jQuery调用 $(\"#action-btn\").on(\"click\", doSomething); // JS类库 - Dojo调用 var btn = dojo.byId(\"action-btn\"); dojo.connect(btn, \"click\", doSomething); 1.2.4 将HTML从JavaScript中抽离 在JS中写入一些HTML文档其实是很常见的行为，但是这会对修改HTML文档造成很大困扰： 在JavaScript中使用HTML的情形往往是给innerHTML属性赋值，比如： //不好的写法 var div = document.getElementById(\"my-div\"); div.innerHTML = \"ErrorInvalid e-mail address.\"; 嵌入JavaScript代码中的HTML标签不便修改（因为很少想到在JS中去修改HTML标签），而且修改也可能会引发太多错误。 ==Web应用本质上是动态的，在页面的生命周期内，JS通常用来修改UI，那么如何用低耦合的方式完成这项工作呢：== 1.2.4.1 方法1：从服务器加载 将模版放置于远程服务器，使用XMLHttpRequest对象来获取外部标签。 这种方法很容易造成XSS漏洞，需要服务器对模板文件做适当转义处理，比如使用<>以及双引号等，当然前端也应当给出与之匹配的渲染规则，总之这种方法需要一揽子前后端的转码和解码策略来尽可能地封堵XSS漏洞。 例如，点击一个链接希望弹出对话框，代码可能如下： function loadDialog(name, oncomplete) { var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"/js/dialog/\" + name, true); xhr.onreadystatechange = function() { if (xhr.readyState == 4 && xhr.status == 200) { var div = document.getElementById(\"dlg-holder\"); div.innerHTML = xhr.responseText; oncomplete(); } else { // 处理错误 } }; xhr.send(null); }//这里没将HTML字符串放在JS里，而是向服务器发起请求获取字符串，这样可以让HTML以最合适的方式注入到页面中。 JS类库将页面中注入HTML代码做了封装，直接给DOM元素挂载内容变得非常方便： //YUI function loadDialog(name, oncomplete) { Y.one(\"#dlg-holder\").load(\"/js/dialog\" + name, oncomplete); } // jQuery function loadDialog(name, oncomplete) { $(\"#dlg-holder\").load(\"/js/dialog\" + name, oncomplete); } 当你需要注入大段HTML标签到页面中时，使用远程调用的方式来加载标签是非常有用的，但是对于少量的标签段，你可以考虑采用客户端模版。 1.2.4.2 方法2：简单客户端模版 本质上，我们并不希望在JS中嵌入模版文本，而是将模板置于他处。 第一种方法：在HTML注释中包含模板文本。然后用JS提取出它们，再用JS将占位符%s替换为真实数据，然后将结果注入DOM。 %s--> First item Second item Third item 第二种方法：使用一个带有自定义type属性的元素。然后再用标签的text属性来提取模板文本。 %s 1.2.4.3 方法3：复杂客户端模版 使用注入Handlebars所提供的解决方案，它是专为浏览器端JavaScript设计的完整的客户端模板系统，也是一个强大的JS模版引擎，详见handlebarsjs官网。 2.避免使用全局变量 原因： 1.如果你给全局环境添加了自己的变量，接下来则会面临读取浏览器附带的内置变量的风险，和浏览器未来的内置API或其他开发者的代码产生冲突的概率极高。 2.一个依赖于全局变量的函数即是深耦合于上下文环境中的，这意味着任何对全局环境的修改都可能造成某处代码出错；同样任何函数也会不经意间修改全局变量，导致对全局变量值的依赖变得不稳定。 （确保你的函数不会对==全局变量==有依赖，这将增强你的代码的可测试性。当然，你的函数可能会依赖原生的JS==全局对象==，比如Date、Array等，它们是全局环境的一部分，是和JS引擎相关的，你的函数总是会用到这些==全局对象==。） 2.1 意外的全局变量 不小心引入的全局变量： function doSomething() { var count = 10; title = \"Maintainable JavaScript\"; // 不小心省略var语句，创建了全局变量 } 避免方法： 1. 总是使用var来定义变量； 2. 函数顶部加入\"use strict\"，使用严格模式，它可以探测未声明变量的赋值操作并且报错该变量没有被定义。 (支持严格模式的环境：IE 10+,FireFox 4+,Safari 5.1+,Opera 12+或Chrome) 2.2 单全局变量和零全局变量 2.2.1 单全局变量方式 单全局变量模式已经在各种流行的JS类库中了： YUI定义了唯一一个YUI全局对象； jQuery定义了两个全局对象，$和jQuery； Dojo定义了一个dojo全局对象； Closure类库定义了一个goog全局对象。 一个多全局对象例子： function Book(title) { this.title = title; this.page = 1; } Book.prototype.turnPage = function(direction) { this.page += direction; }; var Chapter1 = new Book(\"Introduction to Style Guidelines\"); var Chapter2 = new Book(\"Basic Formatting\"); var Chapter3 = new Book(\"Comments\"); 这段代码创建了四个全局对象：Book,Chapter1,Chapter2,Chapter3，单全局变量模式只会创建一个全局对象并将这些对象都赋值为它的属性，如下： var MaintainableJS = {}; MaintainableJS.Book = function(title) { this.title = title; this.page = 1; }; MaintainableJS.Book.prototype.turnPage = function(direction) { this.page += direction; }; MaintainableJS.Chapter1 = new MaintainableJS.Book(\"Introduction to Style Guidelines\"); MaintainableJS.Chapter2 = new MaintainableJS.Book(\"Basic Formatting\"); MaintainableJS.Chapter3 = new MaintainableJS.Book(\"Comments\"); 这段代码只有一个全局对象，即MaintainableJS，其他任何信息都挂载到这个对象上，因为团队中的每个人都知道这个全局对象，因此很容易做到继续为它添加属性以避免全局污染。 2.2.1.1 命名空间 一个常见的约定是每个文件中都通过创建新的全局对象来声明自己的命名空间，在JS中你可以用对象来创建你自己的命名空间，比如： var XuShuai = {}; // 表示这个人的地位的命名空间 XuShuai.Status = {}; // 表示这个人的品性的命名空间 XuShuai.Character = {}; 2.2.1.2 模块 另一种基于单全局变量的扩充方法是使用模块（JS本身不包含正式的模块概念，自然没有模块语法），但有一些通用的模式来创建模块，最流行的两种是“YUI模块”和“异步模块定义”。【自行了解】 2.2.2 零全局变量 一段不会被其他脚本访问到的完全独立的脚本可以做到不用创建全局变量。（因为所有所需的脚本都会合并到一个文件，或者因为这段非常短小且不提供任何接口的代码会被插入至一个页面中。） 最常见的用法是创建一个书签，书签是独立的，我们最终需要一段“零全局变量”的脚本嵌入到页面中，实现方法就是使用一个立即执行的函数调用并将所有脚本放置其中，比如： (function(win) { \"use strict\"; var doc = win.document; // 这里定义其他变量 // 其他相关代码 } (window)); 这个使用严格模式的函数包装器可以用于任何不需要创建全局对象的场景。 3. 事件处理 当事件触发时，事件对象（event对象）会作为回调参数传入事件处理程序中。 本节将用一个例子分步来进行详尽的表述如何构建可维护性的事件处理和事件逻辑。 // 不好的写法 function handleClick(event) { var popup = document.getElementById(\"popup\"); popup.style.left = event.clientX + \"px\"; popup.style.top = event.clientY + \"px\"; popup.className = \"reveal\"; } addListener(element, \"click\", handleClick); 这段代码用event对象的clientX和clientY，在将元素显示在页面之前先用这两个属性给它作定位。这种代码有很多局限性。 然后==隔离应用逻辑==： 你需要将应用逻辑和事件处理的代码拆分开来 // 好的写法 - 拆分应用逻辑 var MyApplication = { handleClick: function(event) { this.showPopup(event); }, showPopup: function(event) { var popup = document.getElementById(\"popup\"); popup.style.left = event.clientX + \"px\"; popup.style.top = event.clientY + \"px\"; popup.className = \"reveal\"; } }; addListener(element, \"click\", function(event) { MyApplication.handleClick(event); }); 把应用逻辑转移到了MyApplication.showPopup(),而MyApplication.handleClick()只做一件事就是调用MyApplication.showPopup()。 如果应用逻辑被剥离出去，对同一段代码的调用可以在多点发生，则不需要一定依赖于某个特定事件的触发，这显然更加方便。 之后==不要分发事件对象==： 上段代码还有一个问题：event对象被无节制地奋发，应用逻辑不应当依赖于event对象来正确完成功能，原因如下： 1.方法接口并没有表明哪些数据是必要的，好的API要更明确清楚。 2.你需要确切地知道这个方法使用了哪些信息，这样在你测试代码时，你重新创建一个event对象并将这个方法作为参数传入的时候，你才会更加方便。 最佳办法就是让事件处理程序使用event对象来处理事件，然后拿到所有需要的数据传给应用逻辑。 // 好的写法 var MyApplication = { handleClick: function(event) { this.showPopup(event.clientX, event.clientY); }, showPopup: function(x, y) { var popup = document.getElementById(\"popup\"); popup.style.left = x + \"px\"; popup.style.top = y + \"px\"; popup.className = \"reveal\"; }// MyApplication.showPopup()方法只需要两个数据，x/y坐标，这里只需接收这两个数据便可。 }; addListener(element, \"click\", function(event) { MyApplication.handleClick(event); }); 这里MyApplication.handleClick()将x/y坐标传入了MyApplication.showPopup()，代替了之前传入的事件对象。 这样可以很清晰地看到MyApplication.showPopup()所期望传入的参数，并且在测试或代码的任意位置都可以很轻易地直接调用这段逻辑，比如： // 这样调用就很好 MyApplication.showPopup(10, 10); ▲当处理事件时，最好让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作，包括阻止默认事件或阻止事件冒泡，都应当直接包含在事件处理程序中。 // 好的做法 var MyApplication = { handleClick: function(event) { // 假设事件支持DOM2 event.preventDefault(); // preventDefault() 方法阻止元素发生默认的行为 event.stopPropagation(); // 该方法将停止事件的传播，阻止它被分派到其他 Document 节点。在事件传播的任何阶段都可以调用它。 // 传入应用逻辑 this.showPopup(event.clientX, event.clientY); }, showPopup: function(x, y) { var popup = document.getElementById(\"popup\"); popup.style.left = x + \"px\"; popup.style.top = y + \"px\"; popup.className = \"reveal\"; }// MyApplication.showPopup()方法只需要两个数据，x/y坐标，这里只需接收这两个数据便可。 }; addListener(element, \"click\", function(event) { MyApplication.handleClick(event); }); 这里清楚地展示了事件处理程序和应用逻辑之间的分工，因为应用逻辑不需要对event产生依赖，进而在很多地方都可以轻松地使用相同的业务逻辑和写测试代码。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:13:18 "},"part3/h5_guide/1.html":{"url":"part3/h5_guide/1.html","title":"1.概览 HTML 整体","keywords":"","body":"一、概览H5 1、H5最重要的三项技术：H5核心规范、CSS、JavaScript. HTML5核心规范定义用以标记内容的元素，并明确其含义。CSS可用于控制标记过的内容呈现在用户面前的外貌。JavaScript则可以用来操纵HTML文档的内容以及相应用户的操作，此外要想使用HTML5新增元素的一些为编程目的设计的特性也需要用到JavaScript。 二、概览HTML标签元素 1、HTML实体：HTML文档中有些字符具有特殊含义，需要用到HTML实体来替代特殊字符。常见的有： > &lt 2、文字从右向左 文字从左向右 3、id属性用来给元素分配一个唯一的标识符。 4、tabindex通过键盘焦点Tab键在各个元素间切换。EG: Name: City: Country: tabindex值为1的元素会第一个被选中，用户按一下Tab按键后，tabindex值为2的那个元素会被选中，依次类推。tabindex设置为-1的元素不会在用户按下Tab键后被选中。所以实施效果是：按下Tab键，键盘焦点从第一个input元素转到第三个，然后转到submit按钮。 三、概览CSS（层叠样式表，Cascading Style Sheets） 1、样式如何层叠： （1）元素内嵌样式（用元素的全局属性style定义的样式） （2）文档内嵌样式（定义在元素中的样式） （3）外部样式（用link元素导入的样式） （4）用户样式（用户定义的样式，以Chrome为例，它在用户的个人配置信息目录中生成一个名为Default\\UserStyleSheet\\Custom.css的文件，添加到这个文件中的任何样式都会被用于用户访问的所有网站）； （5）浏览器样式（浏览器应用的默认样式，例如a｛color:blue; text-decoration:underline;｝）。 【（6）样式具体程度越高，可以覆盖程度低的样式，EG:a.myclass }样式可以覆盖a{ }样式】 【（7）样式定义次序，后面的具体程度相同的样式也会覆盖之前的具体程度相同样式】 2、用重要样式调整层叠次序，EG： a{color:black !important;}//不管样式定义在什么地方，浏览器都会优先考虑这个样式。 3、样式继承：子元素会继承父元素的样式，EG： p{ color:white; background:grey; border:medium solid black; } I like applesand oranges.//这里span标签会继承p标签的样式 令人尴尬的是，并非所有CSS属性都可以继承。这方面有条经验可供参考：与元素外观（文字颜色、字体等）相关的样式会被继承；与元素在页面上的布局相关的样式不会被继承。在样式中使用inherit这个特别设立的值可以强行实施继承，明确指示浏览器在该属性上使用父元素样式中的值。EG： p{ color:white; background:grey; border:medium solid black; } span{ border: inherit; }//span标签继承了P标签的border元素的值。 I like applesand oranges.//这里span标签会继承p标签的样式 4、CSS颜色，一般是十六进制表示颜色，下面是rgb和hsl颜色表示方法： rgba(r,g,b,a) 用RGB模型表示颜色，外加一个用于表示透明度的α值（0代表全透明，1代表完全不透明） 比如： color： rgba(112,128,144,0.4)【也可是rgb(r,g,b)】。 hsl(h,s,l)表示HSL（色相[hue]、饱和度[saturation]、明度[lightness]） 比如：color: hsl(120,100%,22%) 如果增加一个表示透明度的α值就是hsla(h,s,l,a) ▲5、用less改进CSS：http://lesscss.org 四、概览JavaScript 1、定义和使用函数 function myFunc() { document.writeln(\"This is a statement\"); }; myFunc();//使用上面所定义的函数 2、定义带参数和返回结果的函数 function myFunc(name) {//定义一个带参数的函数 return(\"hello,\"+ name + \".\");//返回一个结果值 }; document.writeln(myFunc(\"Nick\")); myFunc();//使用上面所定义的函数 3、使用变量和类型 全局变量和局部变量的定义和作用。 3.1基本类型 字符串类型（String）、数值类型（number）、布尔类型(boolean) 3.2对象 创建对象： var myData = new Object(); myData.name = \"Lucy\"; document.writeln(\"Hello,\" + myData.name + \". \"); 3.2.1使用对象字面量 var myData = { name: \"Lucy\", weather: \"sunny\" };//一口气定义一个对象及其属性 document.writeln(\"Hello,\" + myData.name + \". \"); document.writeln(\"Today is \" + myData.weather + \". \"); 3.2.2为对象添加方法【printMessages()方法】 var myData = { name: \"Lucy\", weather: \"sunny\",//▲这里有逗号了哟 printMessages: function() { document.writeln(\"Hello,\" + this.name + \". \"); document.writeln(\"Today is \" + this.weather + \". \"); //▲在方法内部使用对象属性时要用到this关键字 }//▲这里不用分号了哟 }; myData.printMessages();//调用printMessages()方法 3.2.3对象的增删查改 1、读取修改对象属性值 var myData = { name: \"Lucy\", weather: \"sunny\" }; myData.name = \"Joe\";//name值修改为Joe了【▲这是圆点表示法】 myData[\"weather\"] = \"raining\";//weather值修改为raining了【▲这是类数组索引法】 document.writeln(\"Hello\" + myData.name + \". \"); document.writeln(\"Today is \" + myData[\"weather\"] + \". \"); 枚举对象属性 var myData = { name: \"Lucy\", weather: \"sunny\"， printMessages: function() { document.writeln(\"Hello,\" + this.name + \". \"); document.writeln(\"Today is \" + this.weather + \". \"); //▲在方法内部使用对象属性时要用到this关键字 }//▲这里不用分号了哟 }; for (var prop in myData){ document.writeln(\"Name: \" + prop + \"Value: \" + myData[prop]); } //for...in循环代码块中的语句会对myData对象的每一个属性执行一次，在每一次迭代过程中，所要处理的属性名会被赋给prop变量。这里用类数组索引法获取对象属性值。 代码输出结果如下： Name: name Value： Lucy Name: weather Value： sunny Name:printMessages Value： function() { document.writeln(\"Hello,\" + this.name + \".\"); document.writeln(\"Today is \" + this.weather + \". \");} 2、为对象添加新属性 var myData = { name: \"Lucy\", weather: \"sunny\" }; myData.dayOfWeek = \"Monday\"；//为对象添加一个名为dayOfWeek的新属性 为对象添加新方法 var myData = { name: \"Lucy\", weather: \"sunny\" }; myData.sayHello = function() { document.writeln(\"Hello\"); };//需要使用myData.sayHello()执行这个函数 3、删除对象属性 用delete关键字删除 var myData = { name: \"Lucy\", weather: \"sunny\" }; myData.sayHello = function() { document.writeln(\"Hello\"); }; delete myData.name;//删除对象中的属性值 delete myData[\"weather\"];//删除对象中的属性值 delete myData.sayHello;//删除对象中的方法 4、判断对象是否具有某个属性 可以用in表达式判断对象是否具有某个属性。 var myData = { name: \"Lucy\", weather: \"sunny\" }; var hasName = \"name\" in myData; var hasDate = \"date\" in myData; document.writeln(\"HasName: \" + hasName); document.writeln(\"HasDate: \" + hasDate); 此例分别用一个已有的和一个没有的属性进行测试。hasName变量的值会是true，而hasDate变量的值会是false。 3.3相等和等同测试【易错点】 3.3.1对象的相等和等同测试 var myData1 = { name: \"Lucy\", weather: \"sunny\" }; var myData2 = { name: \"Lucy\", weather: \"sunny\" }; var myData3 = myData2; var test1 = myData1 == myData2; var test2 = myData2 == myData3; var test3 = myData1 === myData2; var test4 = myData2 === myData3; document.writeln(\"Test 1: \" + test1 + \"Test 2: \" + test2): document.writeln(\"Test 3: \" + test3 + \"Test 4: \" + test4): 运行结果： Test 1: false Test 2: true Test 3: false Test 4: true 3.3.2基本类型的相等和等同测试 var myData1 = 5; var myData2 = \"5\"; var myData3 = myData2; var test1 = myData1 == myData2; var test2 = myData2 == myData3; var test3 = myData1 === myData2; var test4 = myData2 === myData3; document.writeln(\"Test 1: \" + test1 + \"Test 2: \" + test2); document.writeln(\"Test 3: \" + test3 + \"Test 4: \" + test4); 运行结果： Test 1: true Test 2: true Test 3: false Test 4: true 3.4显式类型转换【易错点】 字符串连接运算符“+”比加法运算符“+”优先级更高。 var myData1 = 5 + 5; var myData2 = 5 + \"5\"; document.writeln(\"Result 1: \" + myData1); document.writeln(\"Result 2: \" + myData2); 运行结果： Result 1: 10 Result 2: 55//这里正是因为字符串连接运算符比加法运算符优先级更高。 所以： A、将数值转换为字符串有toString()方法toString(2)， toString(8)， toString(16)分别是转换为十进制、二进制、八进制、十六进制。 B、将字符串转换为数值分别有Number()、parseInt()、parseFloat()三种方法。 4、数组 4.1创建和填充数组 var myArray = new Array(); myArray[0] = 100; myArray[1] = \"Adam\"; myArray[0] = true; 首先，创建数组的时候不需要声明数组中元素的个数。其次，不必声明数组所含数据的类型。本例中分别把一个数值、一个字符串和一个布尔值赋给了不同的数组元素。 4.2使用数组字面量 var myArray = [100,\"Adam\",true]; 读取以及修改数组内容: var myArray = [100,\"Adam\",true]; myArray[0] = \"Sunday\";//修改数组内容 document.writeln(\"Index 0: \" + myArray[0]);//读取数组内容 ▲枚举数组内容（把数组中相对应的内容给一一列举出来）： var myArray = [100,\"Adam\",true]; for (var i =0; i 4.3一些数组中的内置方法 concat() 将数组和参数所指数组的内容合并为一个新数组。可以指定多个数组。 join() 将所有数组元素连接为一个字符串。各元素内容用参数指定的字符分隔。 pop() 把数组当作栈使用，删除并返回数组的最后一个元素 push() 把数组当作栈使用，将指定的数据添加到数组中 reverse() 就地反转数组元素的次序 shift（） 类似pop，但是操作的是数组中的第一个元素。 slice(,) 返回一个子数组 sort() 就地对数组元素排序 unshift() 类似push,但新元素被插入到数组的开头位置 5、处理错误 JavaScript用try...catch语句处理错误。 try{ var myArray = [100,\"Adam\",true]; for (var i =0; i 如果没有发生错误，这段代码会正常执行，catch句子会被忽略。但是如果错误发生，那么try句子语句执行将立即停止，控制权转移到catch语句上，发生的错误由一个Error对象描述。最后，无论是否发生错误，都会执行finally这一行打出一行字。 6、分清undefined和null值 如果在读取未赋值的变量或试图读取对象没有的属性时得到的就是undefined，它是在没定义值的情况下得到的值； null是表示已经赋了一个值，但是该值不是一个有效的object/string/number和boolean值（也就是说定义的是一个无值）。 [这里可以看读书笔记：《编写可维护的JS》——1] Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:05 "},"part3/h5_guide/2.html":{"url":"part3/h5_guide/2.html","title":"2.HTML 头部尾部一些知识","keywords":"","body":"一、一些概念性的要点 1、HTML元素负责文档内容的结构和含义，内容的呈现则由CSS样式控制。 二、创建HTML文档 1、base——设置相对URL的解析基准 例如： 345345345345 I like apples and oranges. 百度 新的页面 效果：点击a标签后触发链接为http://xufuping/www.baidu.com或者是xufuping/新的页面.html，如果不用base元素，不设置一个基准URL，浏览器会将当前文档的URL认定为所有相对URL的解析基准。 2、meta作用 2.1指定名/值元数据对——略 2.2声明字符编码 例如： 2.3模拟HTTP标头字段，例如： //每隔5秒就再次载入页面 属性值： refresh 以秒为单位指定时间刷新页面重新载入 default-style 指定页面优先使用的样式表 content-type 另一种声明字符编码的方法。 3、定义CSS样式 3.1style元素中的media属性值，可以将CSS样式适用于规定设备。例如： ……//适用于计算机显示器屏幕 ……//适用于打印预览和打印页面时 3.2media属性值也可以设定在不同大小浏览器窗口显示不同的样式，例如： …… …… 这段代码使用media的width特性区分两组样式。浏览器窗口宽度小于500像素时使用的是第一组样式，川口宽度大于500像素时使用的是第二组。用浏览器打开这个HTML文档，然后拖拉窗口不hi安源用来改变起大小，就能看到这个特性的效果。 3.3 link元素可用来HTML文档和外部资源之间建立联系,例如（载入样式表）： 3.4 link还可以用来为页面定义网站标志，改变浏览器左上角的图标 //这段代码为网站添加了一个浏览器链接栏Logo(图片文件名为：favicon.ico) 4、使用脚本元素的一些知识点 载入脚本使用的代码： 使用async异步执行脚本（打乱次序执行脚本），使用这个属性的一个重要后果是页面中的脚本可能不再按定义他们的次序执行，因此如果脚本使用了其他脚本中定义的函数或值，就不要再使用这个属性了。 noscript元素，可以用来向仅用了JavaScript或浏览器不支持JavaScript的用户显示一些内容，例如： Javascript is required! You cannot use this page without Javascript 或者在浏览器不支持JS时将其引致另一个URL，这需要在noscript元素中加入一个meta元素。例如： 三、标记文字 1、生成内部超链接 到达水果站 这里是水果站：apples,bananas,mangoes 四、一些可考虑的新标签 header元素表示一节的首部，里面可以包含各种适合出现在首部的东西。 footer表示一节的尾部，通常包含着该节的总结信息，还可以包含做着介绍、版权信息、到相关内容的链接、微标以及免责声明等。 nav（添加导航区域）元素表示文档中的一个区域，它包含着到其他页面或同一页面的其它部分的链接。可以用来写导航。 article元素代表HTML文档中一段独立成片的内容。 aside元素用来表示跟周边内容稍沾一点边的内容，类似于书籍或杂志中的侧栏。 details元素在文档中剩一个区域，用户可以展开它来了解关于某主题的更多详情。details元素通常包含一个sunmary元素，后者的作用是为该详情区域生成一个说明标签或标题。例如： 点击我可以展开或许到下面p标签隐藏的内容 我是被隐藏的内容，哈哈哈哈哈哈，嘻嘻嘻嘻嘻嘻 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:07 "},"part3/h5_guide/3.html":{"url":"part3/h5_guide/3.html","title":"3.JS 交互","keywords":"","body":"一、使用Ajax（获取数据） 本笔记概要： 1、发起一个Ajax请求 创建一个XMLHttpRequest对象，然后调用open和send方法 2、使用一次性事件追踪请求的进度 使用第二级的事件，比如onload、onloadstart、onloadend 3、探测和处理错误 相应错误事件，或者使用try...catch语句 4、设置Ajax请求的表头 使用setRequestHeader方法 5、读取服务器相应的标头 使用getResponseHeader和getAllResponseHeaders方法 6、发起跨源Ajax请求 设置服务器响应里的Access-Control-Allow-Origin标头 7、中止一个请求 使用abort方法 1、Ajax起步 一个示例说明： //随着用户点击各个水果按钮，浏览器会异步执行并取回所请求的文档，而主文档不会被重新加载。 //这就是典型的Ajax事件。 Ajax Example Apples Cherries Bananas 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 1.处理响应 function handleResponse(e) { if (e.target.readyState == XMLHttpRequest.DONE && e.target.status == 200) { document.getElementsById(\"target\").innerHTML = e.target.responseText; } } 一旦脚本调用了send方法，浏览器就会在后台发送请求到服务器，因为请求是在后台处理的，所以Ajax依靠时间来通知你这个请求的进展情况。在这个例子中，我们用handleResponse函数处理这些事件。 当readystatechange事件被触发后，浏览器会把一个Event对象传递给指定的处理函数，target属性则会被设为与此事件关联的XMLHttpReques. DONE状态并不意味着请求成功，它只代表请求已完成。可以通过status属性获得HTTP状态码，它会返回一个数值（这里200这个数值代表成功）。只有结合readyState和status属性的值才能够确定某个请求的结果（这个例子中就是只有当readyState的值为DONE并且status的值为200时我才会设置div元素的内容）。 用XMLHttpRequest.responseText属性获得服务器发送的数据，就象这样： document.getElementsById(\"target\").innerHTML = e.target.responseText; responseText会返回一个字符串，代表从服务器上取回的数据。这里用这个属性来设置div元素innerHTML属性的值，以显示被请求文档的内容。（这样就可以构成一个简单的Ajax实例：用户点击一个按钮，浏览器在后台向服务器请求一个文档，当它到达时你处理一个事件，并显示被请求文档的内容。） 2.主流中的异类：应对Opera Opera浏览器的XMLHttpRequest标准实现方式不如其他浏览器那么好或者完整，就如本章实例在其他主流浏览器上能完美工作，但需要做些修改来应对Opera的几个问题。如下： Ajax Example Apples Cherries Bananas 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 第一个问题是，在出发readystatechange事件时不会省城一个Event对象。这就意味着必须把XMLHttpRequest对象指派给一个全局变量，这样才能在以后引用它。这个例子中定义个名为httpRequest的var，随后在handleButtonPress函数创建对象以及handleResponse函数处理已完成时请求调用了它。这个问题就是如果用户在请求处理过程中按下按钮，全局变量就会被指派给一个新的XMLHttpRequest对象，你就无法再与原来那个请求交互了。 第二个问题是Opera没有在XMLHttpRequest对象上定义就绪状态常量。这就意味着你必须用数值来比对readyState属性的值。必须依靠检查4这个数值，而不是XMLHttpRequest. 2.使用Ajax事件 XMLHttpRequest对象定义的事件： abort 在请求被中止时触发 error 在请求失败时触发 load 在请求成功完成时触发 loadend 在请求已完成时触发，无论成功还是发生错误 loadstart 在请求开始时触发 progress 触发以提示请求的进度 readystatechange 在请求生命周期的不同阶段触发 timeout 如果请求超时则触发 （除了readystatechange之外，表中展示的其他事件都定义于XMLHttpRequest规范的第二级。） （浏览器对这些事件支持程度不一，Firefox刘阿兰其有着最完整的支持，Opera完全不支持，而Chrome支持其中的一部分，但是所使用的方式并不符合规范。） （▲考虑到第二级事件的实现还不到位，readystatechange是目前唯一能可靠追踪请求进度的事件。） 3.处理错误 使用Ajax必须留心两类错误，它们之间的区别源于视角不同。 第一类问题是从XMLHttpRequest对象的角度看到的问题：某些因素组织了请求发送到服务器，例如DNS无法解析主机名，链接请求被拒绝或者URL无效。 第二类问题是从应用程序的角度看到的问题，而非XMLHttpRequest对象：它们发生于请求成功发送至服务器，服务器接受请求、进行处理并生成响应，但该响应并不指向你期望的内容时。 一个处理Ajax错误的代码示例： Ajax Example Apples Cherries Bananas Cucumber Bad Host Bad URL 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 3.1处理设置错误 你需要处理的第一类问题是向XMLHttpRequest对象传递了错误的数据，比如格式不正确的URL，它们极其容易发生在生成基于用户输入的URL时，为了模拟这类问题，示例文档添加了一个Bad URL(错误的URL)的button，按下这个button会以下列形式调用open方法： httpRequest.open(\"GET\",\"http://\"); 通常，提示用户在某个input元素里输入一个值，其中的内容会被用于生成Ajax请求所需的URL。当用户触发了请求却没有输入值时，传递给open方法的就会是一个残缺的URL，而上面这句话只有协议部分。 这是一种会阻止请求执行的错误，而XMLHttpRequest对象会在发生这类事件时抛出一个错误。这就意味着你需要用一条try...catch语句来围住设置请求的代码，就像这样： try{ ... httpRequest.open(\"GET\",\"http://\"); ... httpRequest.send(); } catch (error){ displayErrorMsg(\"try/catch\",error.message); } catch子句让你有机会从错误中恢复。可以选择提示用户输入一个值，也可以回退到默认的URL，或者是简单地丢弃这个请求。在这个例子中，仅仅是调用了displayErrorMsg函数来显示错误消息。这个函数是在示例脚本中定义的，它会在ID为errormsg的div元素里显示Error.message这个属性。 3.2处理请求错误 第二类错误发生在请求已生成，但其他方面出错时。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:09 "},"part3/h5_guide/4.html":{"url":"part3/h5_guide/4.html","title":"4.使用多媒体","keywords":"","body":"1、使用video元素 video Video cannot be displayed 如果浏览器不支持video元素或者无法播放视频，那么备用内容就会代替显示。 以下是video元素： autoplay 如果存在，此属性会使浏览器尽可能立刻开始播放视频 preload 告诉浏览器是否要预先载入视频（详情见后） controls 除非此属性存在，否则浏览器不会显示播放控件 loop 如果存在，此属性会让浏览器反复播放视频。 poster 指定在视频数据载入时显示的图片（详情见后） height width 设置高宽 muted 如果此属性存在，视频从一开始就会处于静音状态。 src 指定显示视频来源（详情见后） 1.1预先加载视频 preload属性告诉浏览器：当它加载完包含video元素的网页后，是否应该积极地去下载视频。这样预先加载视频减少了用户播放时的初始延迟，但是如果用户不观看视频则会造成网络宽带的浪费。 这个属性允许的值： none 用户开始播放之前不会载入视频。 metadata 用户开始播放之前只能载入视频的元数据（宽度、高度、第一帧、长度和其他此类信息） auto 请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为。 这个功能自动载入视频会带来更平滑的用户体验，但它可能会大大提升经营成本，如果用户没有观看视频就离开网页，那么这些成本就浪费了。 这个属性的metadata值可以被用来在none和auto值之间建立起适度的平衡。none值的问题在于视频内容会在屏幕上显示为一片空白区域，metadata会让浏览器获取足够的信息来向用户展示视频的第一帧，而不必下载全部内容。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:11 "},"part3/h5_guide/5.html":{"url":"part3/h5_guide/5.html","title":"5.JS 交互","keywords":"","body":"一、使用Ajax（获取数据） 本笔记概要： 1、发起一个Ajax请求 创建一个XMLHttpRequest对象，然后调用open和send方法 2、使用一次性事件追踪请求的进度 使用第二级的事件，比如onload、onloadstart、onloadend 3、探测和处理错误 相应错误事件，或者使用try...catch语句 4、设置Ajax请求的表头 使用setRequestHeader方法 5、读取服务器相应的标头 使用getResponseHeader和getAllResponseHeaders方法 6、发起跨源Ajax请求 设置服务器响应里的Access-Control-Allow-Origin标头 7、中止一个请求 使用abort方法 1、Ajax起步 一个示例说明： //随着用户点击各个水果按钮，浏览器会异步执行并取回所请求的文档，而主文档不会被重新加载。 //这就是典型的Ajax事件。 Ajax Example Apples Cherries Bananas 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 1.处理响应 function handleResponse(e) { if (e.target.readyState == XMLHttpRequest.DONE && e.target.status == 200) { document.getElementsById(\"target\").innerHTML = e.target.responseText; } } 一旦脚本调用了send方法，浏览器就会在后台发送请求到服务器，因为请求是在后台处理的，所以Ajax依靠时间来通知你这个请求的进展情况。在这个例子中，我们用handleResponse函数处理这些事件。 当readystatechange事件被触发后，浏览器会把一个Event对象传递给指定的处理函数，target属性则会被设为与此事件关联的XMLHttpReques. DONE状态并不意味着请求成功，它只代表请求已完成。可以通过status属性获得HTTP状态码，它会返回一个数值（这里200这个数值代表成功）。只有结合readyState和status属性的值才能够确定某个请求的结果（这个例子中就是只有当readyState的值为DONE并且status的值为200时我才会设置div元素的内容）。 用XMLHttpRequest.responseText属性获得服务器发送的数据，就象这样： document.getElementsById(\"target\").innerHTML = e.target.responseText; responseText会返回一个字符串，代表从服务器上取回的数据。这里用这个属性来设置div元素innerHTML属性的值，以显示被请求文档的内容。（这样就可以构成一个简单的Ajax实例：用户点击一个按钮，浏览器在后台向服务器请求一个文档，当它到达时你处理一个事件，并显示被请求文档的内容。） 2.主流中的异类：应对Opera Opera浏览器的XMLHttpRequest标准实现方式不如其他浏览器那么好或者完整，就如本章实例在其他主流浏览器上能完美工作，但需要做些修改来应对Opera的几个问题。如下： Ajax Example Apples Cherries Bananas 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 第一个问题是，在出发readystatechange事件时不会省城一个Event对象。这就意味着必须把XMLHttpRequest对象指派给一个全局变量，这样才能在以后引用它。这个例子中定义个名为httpRequest的var，随后在handleButtonPress函数创建对象以及handleResponse函数处理已完成时请求调用了它。这个问题就是如果用户在请求处理过程中按下按钮，全局变量就会被指派给一个新的XMLHttpRequest对象，你就无法再与原来那个请求交互了。 第二个问题是Opera没有在XMLHttpRequest对象上定义就绪状态常量。这就意味着你必须用数值来比对readyState属性的值。必须依靠检查4这个数值，而不是XMLHttpRequest. 2.使用Ajax事件 XMLHttpRequest对象定义的事件： abort 在请求被中止时触发 error 在请求失败时触发 load 在请求成功完成时触发 loadend 在请求已完成时触发，无论成功还是发生错误 loadstart 在请求开始时触发 progress 触发以提示请求的进度 readystatechange 在请求生命周期的不同阶段触发 timeout 如果请求超时则触发 （除了readystatechange之外，表中展示的其他事件都定义于XMLHttpRequest规范的第二级。） （浏览器对这些事件支持程度不一，Firefox刘阿兰其有着最完整的支持，Opera完全不支持，而Chrome支持其中的一部分，但是所使用的方式并不符合规范。） （▲考虑到第二级事件的实现还不到位，readystatechange是目前唯一能可靠追踪请求进度的事件。） 3.处理错误 使用Ajax必须留心两类错误，它们之间的区别源于视角不同。 第一类问题是从XMLHttpRequest对象的角度看到的问题：某些因素组织了请求发送到服务器，例如DNS无法解析主机名，链接请求被拒绝或者URL无效。 第二类问题是从应用程序的角度看到的问题，而非XMLHttpRequest对象：它们发生于请求成功发送至服务器，服务器接受请求、进行处理并生成响应，但该响应并不指向你期望的内容时。 一个处理Ajax错误的代码示例： Ajax Example Apples Cherries Bananas Cucumber Bad Host Bad URL 你可以点击一个按钮试试 var buttons = document.getElementsByTagName('button'); for (var i = 0; i 3.1处理设置错误 你需要处理的第一类问题是向XMLHttpRequest对象传递了错误的数据，比如格式不正确的URL，它们极其容易发生在生成基于用户输入的URL时，为了模拟这类问题，示例文档添加了一个Bad URL(错误的URL)的button，按下这个button会以下列形式调用open方法： httpRequest.open(\"GET\",\"http://\"); 通常，提示用户在某个input元素里输入一个值，其中的内容会被用于生成Ajax请求所需的URL。当用户触发了请求却没有输入值时，传递给open方法的就会是一个残缺的URL，而上面这句话只有协议部分。 这是一种会阻止请求执行的错误，而XMLHttpRequest对象会在发生这类事件时抛出一个错误。这就意味着你需要用一条try...catch语句来围住设置请求的代码，就像这样： try{ ... httpRequest.open(\"GET\",\"http://\"); ... httpRequest.send(); } catch (error){ displayErrorMsg(\"try/catch\",error.message); } catch子句让你有机会从错误中恢复。可以选择提示用户输入一个值，也可以回退到默认的URL，或者是简单地丢弃这个请求。在这个例子中，仅仅是调用了displayErrorMsg函数来显示错误消息。这个函数是在示例脚本中定义的，它会在ID为errormsg的div元素里显示Error.message这个属性。 3.2处理请求错误 第二类错误发生在请求已生成，但其他方面出错时。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:12 "},"part3/h5_guide/6.html":{"url":"part3/h5_guide/6.html","title":"6.使用多媒体","keywords":"","body":"1、使用video元素 video Video cannot be displayed 如果浏览器不支持video元素或者无法播放视频，那么备用内容就会代替显示。 以下是video元素： autoplay 如果存在，此属性会使浏览器尽可能立刻开始播放视频 preload 告诉浏览器是否要预先载入视频（详情见后） controls 除非此属性存在，否则浏览器不会显示播放控件 loop 如果存在，此属性会让浏览器反复播放视频。 poster 指定在视频数据载入时显示的图片（详情见后） height width 设置高宽 muted 如果此属性存在，视频从一开始就会处于静音状态。 src 指定显示视频来源（详情见后） 1.1预先加载视频 preload属性告诉浏览器：当它加载完包含video元素的网页后，是否应该积极地去下载视频。这样预先加载视频减少了用户播放时的初始延迟，但是如果用户不观看视频则会造成网络宽带的浪费。 这个属性允许的值： none 用户开始播放之前不会载入视频。 metadata 用户开始播放之前只能载入视频的元数据（宽度、高度、第一帧、长度和其他此类信息） auto 请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为。 这个功能自动载入视频会带来更平滑的用户体验，但它可能会大大提升经营成本，如果用户没有观看视频就离开网页，那么这些成本就浪费了。 这个属性的metadata值可以被用来阿紫none和auto值之间建立起适度的平衡。none值的问题在于视频内容会在屏幕上显示为一片空白区域，metadata会让浏览器获取足够的信息来向用户展示视频的第一帧，而不必下载全部内容。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:16:17 "},"part3/angular/1.html":{"url":"part3/angular/1.html","title":"1-入门-走进 AngularJS","keywords":"","body":"Angular ? AngularJS以HTML作为模版语言并扩展HTML元素及属性，使得应用组件开发保持高度清晰、一致。 1.第一个AngularJS应用及剖析 First AngularJS {{\"Hello World!\"}} {{\"Hello AngularJS!\"}} 1.中的ng-app有什么用？ 一是启动AngularJS框架，二是告诉AngularJS框架从ng-app指令所在标签的开始标签到结束标签之间的所有DOM元素由AngularJS框架进行管理。 2.{{}}是AngularJS的表达式形式，中间为表达式内容。 上面的例子中，表达式为字符串字面量，AngularJS会将该字面量输出到页面。 2.AngularJS应用构成元素 模型(Model)：AngularJS程序中用于展示到页面的数据，本质是一个JavaScript对象。 视图(View)：从用户角度来看，视图就是用户所看到的网页内容；从AngularJS应用的角度来说，视图则是AngularJS指令与表达式经过解析后的DOM元素。 控制器(Controller)：AngularJS应用中用于处理业务逻辑的JavaScript方法。 作用域(Scope)：可以把作用域理解为一个容器，在控制器中可以访问这个容器，然后往容器中放入一些模型数据，在视图中就可以通过表达式将数据展现给用户。 指令(Directives)：扩展的HTML属性或标签，能够被AngularJS框架识别，根据不同的指令执行相应的动作。例如，前面提到的ng-app指令，作为html元素的扩展属性，能够被AngularJS框架识别，从而启动AngularJS框架。 表达式(Expressions)：用于向页面输出信息，在前面已经接触过，下节将会对表达式做更详细的介绍。 模板(Template)：AngularJS以HTML作为模版语言，AngularJS模板实际上就是HTML片段。 3.AngularJS表达式 表达式的定义方式： 可以在其中加入四则运算，逻辑运算，可以通过表达式输出作用域内容。(==ng-init用于在标签中初始化作用域==，并可以在其中添加对象、数组等类型。) Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:18:23 "},"part3/angular/2.html":{"url":"part3/angular/2.html","title":"2-入门-双向数据绑定","keywords":"","body":"数据绑定是 AngularJS 框架最优秀的特性之一，能够帮助 Web 前端开发人员在很大程度上减少对 DOM 的操作。 1. 双向数据绑定，ng-model，ng-bind 数据绑定是 AngularJS 框架在视图（DOM 元素）与作用域之间建立的数据同步机制。“双向”：是指界面的操作能够实时同步到作用域中，作用域中的数据修改也能够实时回显到界面中。 ng-model 可以建立数据绑定，只能用在表单元素上 input输入框添加ng-model指令后，AJS框架就会在对应的作用域中创建一个uname属性和该输入框进行绑定。 数据绑定实例-表单中数据回显到页面中： First AngularJS 用户名： {{uname}} 上面的案例中ng-app指令用于启动AJS，当AJS遇到ng-app就会创建一个名为$rootSocpe得到作用域，该作用域为AJS应用的根作用域。 作用域其实是一个简单的JavaScript对象，形式如下： var $rootScope={uname:\"我是表单里输入的内容\"}; 在上面的例子中，我们向$rootScope作用域中添加属性进行了数据绑定，会造成全局作用域污染，实际项目中并不会这么做。 而是把表单和控制器作用域中的属性进行数据绑定，控制器作用域是根作用域$rootScope的子作用域。（后面会有接触。） ng-bind 是实现作用域到视图的单向数据绑定，可用于向界面中输出作用域中的数据。 上面例子中的 {{uname}} /可以更换为 /或者更换为 // 使用{{name}}时，加载缓慢会直接把AJS当作字符串解析，用户体验会很不好，所以推荐使用ng-bind指令。ng-bind指令只在AJS加载完毕之后才会执行。 当我们需要进行运算处理或者使用过滤器对输出内容进行处理时，则必须用表达式：{{}} 2. 数据绑定实例：价格计算器 First AngularJS 单价： 数量： 总价： Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:22:14 "},"part3/angular/3.html":{"url":"part3/angular/3.html","title":"3-入门-AJS 与 MVC，应用模块化","keywords":"","body":"MVC是一种软件架构模式，MVC的核心思想是把数据的管理、业务逻辑控制和数据的的展示分离开，使程序的逻辑性和可维护性更强。 1. AngularJS的MVC Model:前面提到过的作用域对象（如$rootScope对象）中的属性。 View:大家所熟悉的DOM元素，从用户的角度来看就是HTML页面，在View中可以通过AngularJS表达式访问模型数据。 Controller:用户自定义的构造方法，作用域中的模型数据可以通过依赖注入的方式注入控制器中。 1.1 AngularJS控制器的定义 我们是用模块实例controller()方法来声明一个控制器，该方法接收两个参数，第一个参数为控制器名称，第二个参数为一个匿名方法，即控制器的构造方法，用法如下： var app = angular.module(\"app\", []); app.controller(\"LoginController\", function($scope, $log) { $scope.name = \"admin\"; $scope.pword = \"123456\"; }); AJS在windows对象中添加了一个全局的angular对象，我们调用angular对象的module()方法返回一个模块实例，然后调用模块实例的controller()方法来声明一个控制器。 在上面的案例中我们定义控制器时指定了$scope和$log两个参数： $scope是作用域对象，是控制器与视图之间传递信息的载体; $log为AngularJS框架内置的日志服务对象，用于向控制台中输入日志信息。 当我们为控制器构造方法指定这两个参数后，表示控制器依赖于这两个对象，控制器实例化时会把这两个对象注入控制器中。 1.2 控制器：ng-controller AJS遇到ng-controller时会根据ng-controller指定的控制器名称查找控制器构造方法，然后使用对应的构造方法实例化控制器对象，并将控制器依赖的对象注入控制器对象中。 每个控制器对应的作用域对象只能与ng-controller所在标签的开始标签和结束标签之间的DOM元素建立数据绑定。 First AngularJS 用户名: 密码: 提交 你输入的用户名：{{name}} 你输入的密码：{{pword}} 个人爱好： 你输入的个人爱好： {{love}} function UserController($scope, $log) { $scope.name = \"admin\"; $scope.pword = \"123456\"; $log.info(\"UserController->name:\" + $scope.name); $log.info(\"UserController->pword\" + $scope.pword); } function InfoContoller($scope, $log) { $scope.love = \"足球\"; $log.info(\"InfoContoller->name:\" + $scope.name); $log.info(\"InfoContoller->pword\" + $scope.pword); $log.info(\"InfoContoller->love\" + $scope.love); } var app = angular.module(\"app\", []); app.controller (\"UserController\", UserController); app.controller (\"InfoContoller\",InfoContoller); AJS应用中的DOM事件处理可以在控制其中完成，AJS框架为我们提供了一系列的事件绑定指令，这些指令是在原生的JS事件名称前加“ng-”前缀，例如ng-click、ng-keyup等。 2. 应用模块化 应用模块划分的重要性： 1.使程序实现逻辑更加清晰； 2.合作开发更加明确，容易控制； 3.充分利用可以重用的代码； 4.抽象出可公用的模块，可维护性强，以避免同一处修改在多个地方出现； 5.可基于模块化设计优秀的遗留系统，方便组装开发新的相似系统，甚至一个全新的的系统。 2.1 AngularJS中的模块 定义：调用angular对象的module()方法返回一个模块实例。 angular.module()方法能够接收3个参数： 1.第一个参数为模块的名称； 2.第二个参数是一个数组，用于指定该模块依赖的模块名称。如果不需要依赖其他模块，第二个参数传递一个空数组即可； 3.第三个参数为可选参数，该参数接收一个方法，用于对模块进行配置，作用和模块实例的config()方法相同。 PS：angular.module()方法返回一个模块实例对象，我们可以调用该对象的controller()、directive()、filter()等方法向模块中添加控制器、指令、过滤器等其他组件。 // 定义一个无依赖模块 angular.module('appModule', []); // 定义一个依赖module1、module2的模块 angular.module('appModule', ['module1', 'module2']); 在HTML引用模块： 使用模块解决命名冲突问题：调用angular.module()方法创建两个或者多个模块，以不同名称命名，然后在不同页面使用ng-app调用对应名称模块下的内容。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:18:27 "},"part3/angular/4.html":{"url":"part3/angular/4.html","title":"4-入门-作用域与事件","keywords":"","body":"1. AngularJS 作用域详解 AJS 作用域本质上就是普通的 JavaScript 对象，可以在作用域对象中增加属性或者方法，我们不需手动构造 AJS 作用域对象，注入 ng-app 和 ng-controller 时 AJS 会自动创建作用域对象。 每个 AJS 应用至少会有一个名称为$rootScope 的作用域，它是 AngularJS 应用的根作用域，也就是所有作用域的父作用域。 作用域1继承自$rootScope作用域，作用域2则会继承作用域1，$rootScope和作用域1中的属性在作用域2中均能访问。 2. 作用域继承 2.1 JS 对象继承机制： 1.构造方法原型链继承 每一个 JS 构造方法都有一个名为 prototype 的属性，可以指向另一个对象。当我们访问对象属性时，JS 引擎会从对象的所有属性中查找该属性，如果找到就返回，如果没有找到就沿着 prototype 一直查找下去，直到 prototype 链结束或找到对象为止。 2.使用 apply、call 方法实现继承 JS 中的 apply()、call()方法可以改变对象构造中“this”的上下文环境，使特定的对象实例具有对象构造中所定义的属性、方法。apply()方法只接收两个参数，第二个参数是一个数组，而 call()方法可以接收多个参数。 --> First AngularJS --> function Person(name, age) { this.name = name; this.age = age; } function Student(name, age, love) { // Person.apply(this, [name, age]); Person.call(this, name, age); this.love = love; } var student = new Student(\"xushao\", \"18\", \"basketball\"); console.log(\"student.name=\" + student.name); console.log(\"student.age=\" + student.age); console.log(\"student.love=\" + student.love); 结果： student.name=xushao shiyan.html:21 student.age=18 shiyan.html:22 student.love=basketball 3.对象实例间继承 使用 Object.create()方法，以一个对象为原型创建另外一个对象，创建的对象和原对象有相同属性。 --> First AngularJS --> function Person(name, age) { this.name = name; this.age = age; } var person = new Person(\"xushuai\", 18); var student = Object.create(person); student.love = \"swim\"; console.log(Object.getPrototypeOf(student)); console.log(\"student.name=\" + student.name); console.log(\"student.age=\" + student.age); console.log(\"student.love=\" + student.love); 输出： Person shiyan.html:18 student.name=xushuai shiyan.html:19 student.age=18 shiyan.html:20 student.love=swim 2.2 AJS 作用域对象原型继承 AngularJS 作用域对象继承采用 JS 第一种方式——构造方法原型链继承。AngularJS 作用域构造方法中提供了一个$new()成员方法，用于创建子作用域。 var parent = $rootScope; var child = parent.$new(); (除了ng-app、ng-controller指令会创建作用域对象外，AngularJS指令也可能会产生子作用域，后面内容会接触到。) 2.3 作用域高级特性 2.3.1 $watch 方法监视作用域 $watch 方法可以帮助我们监视作用域中属性的变化。但是对待基本类型和引用类型时会有不同的处理方式。 $watch()方法可以接收三个参数，第一个参数是需要监视的属性，第二个参数是在监视属性发生变化时需要回调的方法，实际上$watch()方法还能接收第三个参数，默认情况下参数值为 false。（false：“引用监视”，只要监视得到对象引用没有发生变化，就不算它发生变化；true：“全等监视”，只要监视的属性发生变化，就会触发监视机制的回调方法。全等监视会消耗大量资源，尤其是对于大型项目来说；$watchCollection()方法针对数组项数进行监视，它的性能在全等监视和引用监视之间。） 可以调用$watch()返回的方法 unbindWatcher()解除作用域监视。 2.3.2 $apply与$digest 循环 AJS 作用域中模型数据发生变化时，AJS 会自动触发$digest玄幻，从而达到自动更新视图的目的。但有时例如用setTimeout()方法来更新一个模型数据就需要手动调用$apply()方法触发$digest 循环。 First AngularJS 3秒后回显信息 {{message}} angular.module(\"msgModule\", []).controller(\"MsgController\", function($scope) { $scope.scheduleTask = function() { setTimeout(function() { $scope.$apply(function() { //这里需要调用$apply()方法触发$digest循环 $scope.message = \"信息内容\"; console.log(\"message=\" + $scope.message); }); }, 3000); } }); 2.3.3 $timeout与$interval 服务介绍 在 js 中，我们使用 setTimeout()方法达到延迟执行某个方法的效果，我们使用 setInterval()每隔一段时间调用一次特定的 js 方法，我们在 AJS 中使用这两个方法都需要手动调用$apply()方法来触发$digest。 使用 AJS 内置的指令或服务就不需要我们手动调用$apply()方法触发$digest 循环，AJS 为我们提供了两个实用的服务$timeout和$interval，功能和 setTimeout()、setInterval（）相同。 例如： First AngularJS 3秒后回显信息 {{message}} angular.module('msgModule', []) .controller('MsgController', function($scope, $timeout) { $scope.scheduleTask = function() { $timeout(function() { $scope.message = \"信息内容\"; console.log(\"message\"+$scope.message); }, 3000); } }); 2.4 作用域事件路由与广播 AJS 作用域支持下面两种事件传播方式： 事件从子作用域路由到父作用域中 事件从父作用域广播到所有子作用域中 2.4.1 $emit 方法实现事件路由 AngularJS 作用域对象提供了一个$emit()方法，用于实现事件从子作用域路由到父作用域中，$emit 方法第一个参数为事件名称，后面可以传入一个或多个参数，这些参数可以被传递到父作用域注册的事件监听器中。 例如：$scope.$emit(\"infoEvent\", {name:\"Jane\", age:23}); 消息发送出去后，我们可以在父作用域中调用AJS作用域对象的$on()方法，注册一个事件监听器监听子作用域路由的事件。 如下案例： AngularJS #parent{ width: 350px; height: 250px; border: 3px solid #ccc; } #child{ width: 300px; height: 200px; border: 3px solid #ccc; margin: 10px auto; } 父作用域 子作用域 Emit var app = angular.module(\"eventModule\", []) app.controller(\"ParentController\", function($scope) { $scope.$on(\"infoEvent\", function(event, data) { console.log(\"在父作用域接收到子作用域点击事件返回内容\"); console.log(data); }); }); app.controller(\"ChildController\", function($scope) { $scope.postEvent = function(){ $scope.$emit(\"infoEvent\", {name:\"Jane\", age:23}); } }); 2.4.2 $broadcast 方法实现事件广播 $broadcast()方法的使用和$emit()方法相同，不同的是它用于向子作用域广播事件，所有的子作用域只要注册了事件监听器就能收到父作用域的广播事件。 AngularJS_broadcast #parent{ width: 450px; height: 250px; border: 3px solid #ccc; } .child{ width: 150px; height: 200px; border: 3px solid #ccc; float: left; margin-left: 20px; } 父作用域Broadcast 子作用域1 子作用域2 var app = angular.module(\"eventModule\", []) app.controller('ParentController', function($scope) { $scope.postEvent = function() { $scope.$broadcast(\"infoEvent\", {name:\"Jane\", age:23, string:\"我是父作用域的内容\"}); } }); app.controller('Child1Controller', function($scope){ $scope.$on(\"infoEvent\", function(event, data) { console.log(\"子作用域1接收到父作用域广播事件...\"); console.log(data); }); }); app.controller('Child2Controller', function($scope){ $scope.$on(\"infoEvent\", function(event, data) { console.log(\"子作用域2接收到父作用域广播事件...\"); console.log(data); }); }); 2.4.3 作用域对象$on 方法详解 $on()方法用于注册一个事件监听器，该方法接收两个参数，第一个参数是要监听事件的名称，第二个参数是事件处理方法： $scope.$on(\"infoEvent\", function(event, data){ }); //事件处理方法得到第一个参数event为事件对象，第二个参数data为调用$emit()或$broadcast()方法传递的数据 //event事件对象有一些实用的属性和方法，如下： 1.event.name: 事件的名称。 2.event.targetScope: 事件源作用域对象。 3.event.currentScope: 当前作用域对象。 4.event.stopPropagation(): 用于停止事件的进一步传播，需要注意的是该方法只对向父作用域路由事件起作用比如$emit()方法，调用此方法将不会再向上级父作用域路由。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:18:34 "},"part3/angular/5.html":{"url":"part3/angular/5.html","title":"5-路由与多视图","keywords":"","body":"1 创建多视图应用 建立URL到AngularJS视图的映射，我们要用到AngularJS的一个内置Provider对象$routeProvider，该对象用于创建路由映射，提供了一个 when(path, route)方法和otherwise(params)方法： 1. when(path, route): path: string类型，路由路径（和$location.path相对应）。path中可以使用占位符，需要使用“：”隔开，例如/ShowOrders:Num(可以是一个参数). route:Object类型，用于配置映射信息。 controller:{string|function}类型，用于指定控制器名称或控制器构造方法。 controllerAs:string类型，通过控制器标识符名称引用控制器。 template:{string|function}类型，string类型-指定视图模板;function方法-必须返回HTML模板内容。 templateUrl:string类型，用于指定视图模板文件路径。 resolve:Object类型，用于指定注入控制器中的内容。 2. otherwise(params):接收一个string类型参数，用于匹配路由中未定义的URL。 示例： 多视图 // AJS路由模块为ngRoute，作为一个单独的模块定义在angular-route.js文件中，所以我们必须在页面中引入它。 .mainDiv{ margin: 25px 50px 75px 100px; } 订单列表 新增订单 /* ng-view是AJS的一个内置指令，用于定义一个视口。有如下三种写法： 1. 2. 3. */ var routeModule = angular.module(\"routeModule\", [\"ngRoute\"]); // AngularJS作为一个单独的模块，模块名称为ngRoute，我们如果在自定义的模块中使用它，需要添加ngRoute模块依赖。 routeModule.config([\"$routeProvider\", function($routeProvider) { // config()会在模块加载时被执行，主要用于对服务进行配置。 $routeProvider .when('/addOrder', { templateUrl: 'templates/addOrder.html', // controller: 'AddOrderController' }) .when('/showOrders', { templateUrl: 'templates/showOrders.html', // controller: 'ShowOrderController' }) .otherwise({ redirectTo: '/addOrder' }); }]); 加载的页面如下： templates/addOrder.html: 新增订单页面 templates/showOrders.html: 显示订单列表页面 2 通过URL向控制器传递参数 示例：通过URL传递参数 =此处示例有待补充 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:18:37 "},"part3/js_succinct/1.html":{"url":"part3/js_succinct/1.html","title":"1.语法和对象","keywords":"","body":"1.语法 1.1 枚举(for in) for (myvar in obj) { if (obj.hasOwnProperty(myvar)) { ... } } 1.2 运算符优先级 运算符 作用 . [] () 提取属性与调用函数 delete new typeof + - ! 一元运算符 * / % 乘法、除法、求余 + - 加法/连接、减法 >= 不等式运算符 === !== 等式运算符 && 逻辑与 \\ \\ 逻辑非 ?: 三元 2.对象 2.1 对象简述 JS的简单数据类型包括数字、字符串、布尔值(true和false)、null和undefined。其它所有值都是对象。JS中，数组、函数、正则表达式和对象都是对象。 JS的对象是无类型的，它对新属性的名字和属性的值没有限制，对象适合用于汇集和管理数据，对象可以包含其他对象，所以它们可以容易地表示成树状或图形结构。 2.2 对象字面量 1.一个对象字面量就是包围在一个花括号中的零或多个“名/值”对 2.不强制要求用引号括住属性名，但必须用引号括住值 3.逗号分隔多个“名/值”对 4.对象可嵌套 var XuQingfeng = { appearance:\"handsome\", age:\"20\", hobby:{ motion:\"swimming\", food:\"prawns\" } }; 2.3 检索 1.可以采用在[]后缀中括住一个字符串表达式检索对象里包含的值，也可以用.表示法。 stooge[\"first-name\"] //\"xu\" flight.departure.last-name //\"qingfeng\" 2. || 运算符可以用来填充默认值 var status = flight.status || \"there is none\" 2.4 引用 对象通过引用来传递。它们永远不会被复制。 var x = stooge; x.name = \"shuai\"; var Qingfeng = stooge.name; // 因为x和stooge是指向同一个对象的引用，所以Qingfeng为“shuai”。 2.5 原型 每个对象都会链接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到Object.prototype,它是JS中的标配对象。 原型链接只有在检索值的时候才被用到。如果我们尝试去获取对象的某个属性值，但是该对象没有此属性名，那么JS会试着从原型对象中获取属性值。如果那么原型对象也没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到达终点==Object.prototype==。如果想要的属性完全不存在于原型链中，那么结果就是undefined值。这个过程称为==委托==。 原型关系是一种动态的关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。 2.6 反射 使用typeof操作符检测对象属性: typeof Qingfeng.status // 'number' 请注意原型链中的任何属性都会产生值: typeof Qingfeng.toString // 'function' 有两种方法处理掉这些不需要的属性: 1.让你的程序检查并丢弃值为函数的属性。 if (typeof Object.Qingfeng !== 'function') { …… } 2.另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，它将返回true。hasOwnProperty方法不会检查原型链。 Qingfeng.hasOwnProperty('number') // true Qingfeng.hasOwnProperty('constructor') // false 2.7 枚举 ==for-in==用来便利对象中的所有属性名。但是会列出所有的属性-包括函数和原型中的属性，所以有必要过滤这些你可能不需要的值。常用的过滤器是==hasOwnProperty==方法和==typeof==来排除函数。 var name; for (name in Qingfeng) { if (typeof Qingfeng.name !== 'function') { document.writeLn(name + ':' + Qingfeng.name); } } 2.8 删除 delete运算符可以用来删除对象具有的某个属性。它不会触及原型链中的任何对象，但是删除对象的属性可能会让来自原型链中的属性透现出来： Qingfeng.name // 'xfp' // 删除 Qingfeng 的 name 属性，从而暴露出原型的 name 属性。 delete Qingfeng.name; Qingfeng.name // 'shuai' 2.9 减少全局变量污染 最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量： var Qingfeng = {}; 该变量此时变成了你的应用的容器： Qingfeng.name = { firstName : \"Xu\", lastNanme : \"Fuping\" } 把全局性的资源纳入一个名称空间下，你的程序与其他应用程序、组件或类库之间发生冲突的可能性就会显著降低。当然，也可以使用闭包来进行信息隐藏的方式，它是另一种有效减少全局污染的方法。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:08:53 "},"part3/js_succinct/2.html":{"url":"part3/js_succinct/2.html","title":"2.函数","keywords":"","body":"1.函数 1.1 函数对象 JS中的函数就是对象。所以它们可以像任何其他的值一样被使用。 对象字面量产生的对象链接到 ==Object.prototype==。函数对象连接到 ==Function.prototype==。 函数可以保存在变量、对象和数组中。函数可以被当作参数传递给其他函数。函数也可以再返回函数。函数可以拥有方法。当然，函数的与众不同之处在于它们可以被调用。 1.2 函数字面量 函数对象通过函数字面量来创建： // 创建一个名为 add 的变量，并用来把两个数字相加的函数赋值给它 var add = function (a, b) { return a + b; }; 函数字面量包括4个部分： 1.第一个部分是保留字function。 2.第二个部分是函数名，它可以被省略。函数可以用它的名字来递归地调用自己。如果没有给函数命名，则被称为匿名函数。 3.第三个部分是包围在圆括号中的一组参数。多个参数用逗号分隔。这些参数的名称将被定义为函数中的变量。它们不被初始化为undefined,而是在该函数被调用时初始化为实际提供的参数的值。 4.第四个部分是花括号中的一组语句。这些语句是函数的主体，它们在函数被调用时执行。 函数字面量可以出现在任何允许表达式出现的地方。 函数也可以被定义在其他函数中。一个内部函数除了可以访问自己的参数和变量，同时也能自由访问把它嵌套在其中的父函数的参数与变量。 通过函数字面量创建的函数对象包含一个连到外部上下文的连接。这被成为闭包。 1.3 调用 调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:08:56 "},"part3/json/1.html":{"url":"part3/json/1.html","title":"1.基础了解","keywords":"","body":"1.一些JSON基础知识 1.JSON是一种数据交换格式 2.为了获得最大可移植性，应尽可能避免使用空格或特殊字符。 3.使用下列字符，告诉机器如何读取数据： { 开始读取对象 } 结束读取对象 [ 开始读取数组 ] 结束读取数组 : 在“名称——值对”中分隔名称和值 , 分隔对象中的“名称——值对”或者分隔“数组中的值”；也可以认为是“一个新部分得到开始” 4.双引号： JSON是基于JavaScript的对象字面量的，所以和JavaScript对象字面量很像，但是JS对象字面量不需要给名称——值对中的名称两边加上双引号，而在JSON中，必须给两边都要加上双引号，且不可用单引号代替双引号。例如： //这不是合法的JSON { 'title':\"this is my title.\", 'body' :\"this is the body.\" } //合法的JSON { \"title\": \"this is my title.\", \"body\" : \"this is the body.\" } 5.JSON的MIME类型是 application/json 2.JSON的数据类型 1.包含：对象、字符串、数字、布尔值、null、数组 2.JSON本身就是对象，也就是一个被花括号包裹的名称——值对的列表，如果你希望在作为对象的JSON中创建一个名称——值对，那就需要用到嵌套。 实例3-3：嵌套对象 { \"person\": { \"name\": \"linda\", \"heightInInches\": 66, \"head\":{ \"hair\":{ \"color\": \"yellow\", \"length\": \"short\", \"style\": \"A-line\" }, \"eyes\":\"green\" } } } 3.使用反斜线对字符串中的双引号进行转义 \\\"\\\"（代表\"\"） \\\\（代表\\） \\/（正斜线） \\b（退格符） \\f（换页符） \\t（制表符） \\n（换行符） \\r（回车符） \\u（后面跟十六进制符 例如：笑脸表情 \\u263A） 4.JSON中的null类型 null就是用来表示0、一无所有、不存在等意思，而不是用数字来表示。 不能把null和undefined混淆，undefined不是JSON中的数据类型。在JS中，undefined是在尝试获取一些不存在的对象或变量时返回的结果。 null是一个“没有值”的值，在JSON中，null必须使用小写形式。 5.JSON中的数组例子： //例一：使用由对象构成的数组来表示一场考试的问题和答案 { \"test\":[ { \"question\": \"the sky is blue.\", \"answer\": true }, { \"question\": \"the earth is flat.\", \"answer\": false }, { \"question\": \"A cat is a dog.\", \"answer\": false } ] } //例二：使用由数组构成的数组来表示三场不同考试的答案 { \"test\":[ [ true, false, false, false ], [ true, true, true, true, false ], [ true, false, true ], ] } 备注： 1.对象和数组很关键的一个区别就是，对象是名称——值对构成的列表或集合，数组是值构成的列表集合。 2.对象和数组另一个关键的区别是，数组中所有的值应具有相同的数据类型。 3.JSON Schema 交互时需要响应，我们称为“一致性验证”，Schema（意为模式） 作用： 1.通过验证数据与Schema的一致性，你轻松地定位和修复了错误。你从每个错误中都能得到许多有用的信息。 2.创建好了数据并且信心十足。 3.你从网上将数据发送过去，并收到了成功响应。任务完成。 使用Schema： 1.声明的名称必须是\"$schema\",它的值必须为所用版本的链接：\"http://json-schema.org/draft-04/schema#\" 2.第二个名称-值对应该是JSON Schema文件的标题。例如： { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"Cat\" } 3.定义对象属性，例如： { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"Cat\", \"properties\": { \"name\": { \"type\": \"string\" }, \"age\": { \"type\": \"number\", \"description\": \"Your cat's age in years.\" }, \"declawed\": { \"type\": \"boolean\" } } } 4.最后验证JSON是否符合JSON Schema. //下列JSON符合定义的JSON Schema { \"name\": \"Fluffy\", \"age\": 2, \"declawed\": false } 这里只是验证了值的数据类型是否正确。 验证规定的一定要包含的JSON对象字段——required. { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"Cat\", \"properties\": { \"name\": { \"type\": \"string\" }, \"age\": { \"type\": \"number\", \"description\": \"Your cat's age in years.\" }, \"declawed\": { \"type\": \"boolean\" }, \"description\": { \"type\": \"string\" } }, \"required\": [ \"name\", \"age\", \"declawed\" ] } //针对上面的合法JSON { \"name\": \"Fluffy\", \"age\": 2, \"declawed\": false, \"description\": \"Fluffy loves to sleep all day.\" }//因为required没有要求description，如果没有description，也是合法的JSON. 但是下面这个也是合法的JSON: {}//因为这里对JSON没有值的形式要求。 更详细的对JSON类型的格式要求 { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"Cat\", \"properties\": { \"name\": { \"type\": \"string\", \"minLength\": 3, \"maxLength\": 20 },//名字的范围不少于3个字符，不多于20个字符 \"age\": { \"type\": \"number\", \"description\": \"Your cat's age in years.\", \"minumum\": 0 },//这里保证小猫的年龄不为负数 \"declawed\": { \"type\": \"boolean\" }, \"description\": { \"type\": \"string\" } }, \"required\": [ \"name\", \"age\", \"declawed\" ] } //这是不能通过验证的JSON { \"name\": \"xi\",//名字最少3个字符 \"age\": -1,//年龄最小值为0 \"declawed\": false, \"description\": \"Fluffy loves to sleep all day.\" } 补充：JSON还支持正则表达式以及枚举类型（一个包含所有科能值的列表）。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:20:08 "},"part3/json/2.html":{"url":"part3/json/2.html","title":"2.深入了解与熟悉通透","keywords":"","body":"1.JSON中的安全问题 Web中使用JSON时最常见的两个安全问题：跨站请求伪造和跨站脚本攻击。 客户端和服务端的关系： 当我们提起客户端代码时，通常指的是javascript、HTML、CSS; 当我们提到服务端代码时，常常是指一些服务端语言，如ASP.NET、Ruby on Rails、Java. 1.1跨站请求伪造（CSRF） 含义：利用站点对用户浏览器信任而发起攻击的方式。 例如： [ { \"user\": \"bobbarker\" }, { \"phone\": \"555-555-5555\" } ]//这种情况称为顶层JSON数组，它是合法的JSON，但是它们也是可以执行的JavaScript脚本。 如何阻止CSRF攻击： 1.首先，应该将数组作为一个值存入JSON对象，这样数组将不再是合法的JavaScript. { \"info\":[ { \"user\": \"bobbarker\" }, { \"phone\": \"555-555-5555\" } ] }//将数组存放到对象之中，使其成为非法的javascript，这样就不会被标签加载. 2.下一步，应仅允许POST请求获取数据的时候，禁止使用GET请求，这样黑客便无法使用他自己的URL中的链接了。 GET用于请求数据，得到响应；POST用于提交数据，得到响应。 如果服务器端允许GET请求，就可以直接通过浏览器或标签链接到它，但POST就不可以直接被链接到。 PS：用户敏感数据也是引发窃取行为的关键。不在JSON中使用顶级数组，不要贪图使用GET代替POST的便利，这样你就不会写出那些满是漏洞、让用户感到愤怒的代码。 1.2注入攻击 含义：利用系统本身的漏洞来实现的。 1.2.1跨站脚本攻击 理解：JSON本身仅仅是文本，在编程中，如果想要对代表对象的文本进行操作，首先要将它转换成对象并装入内存中，这样它才能被编辑操作。 在JS中，可以使用eval()函数来进行这一操作，获取一段字符串，并对其编译与执行。但是，在有些情况下，我们的JSON是从别的服务器上获取的，该服务器通常会是你无权控制的第三方服务器。如果服务器本身或发来的JSON数据被人劫持，那么很可能就会运行恶意代码。eval()的问题就是它会将传入的字符串无差别地编译执行，如果被劫持并替换恶意脚本，那么访问站点就会无辜蒙冤。 JSON.parse()可以用来解决这样的问题，该函数仅会解析JSON，并不会执行脚本。【有一小部分老式浏览器不兼容该函数，可以将这一错误捕获，并弹出一条形如“请升级你的浏览器至最新版本”，来避免用户看到满是错误的页面】 1.2.2安全漏洞：决策上的失误 1.采取手段使得JSON消息中不包含HTML，可以在客户端和服务端都加上这一认证。 2.将消息中所有的HTML字符进行转码。 诸如这样的标签就会被转换成&lt;div&gt;，然后插入页面(&lt;div&gt;将不会是合法的HTML). 总之：允许在JSON中使用HTML以及直接将值插入页面都是一些幼稚的决策。抵御注入攻击的关键是要找出可能的注入点，并加入一些额外的步骤(有时可能会很麻烦)来加以防范。 2.JS中的XMLHttpRequest与Web API javascript中的XMLHttpRequest负责在客户端发起请求，而Web API负责在服务端返回响应。 URL的全称是通用资源标识符，我们在浏览器中使用的URL通常指向HTML资源。 2.1 Web API Web API 是通过HTTP服务进行交互的一族指令和标准。这些交互可以包括创建、读取、更新、删除(CRDU)等操作。 我们创建某段JSON数据后进行交互，JS在幕后进行的这些操作，比如请求天气数据，成为异步操作。异步操作通常指那些发生在幕后的、不会中断主进程的操作。在JS的异步操作中，“主进程”指Web浏览器的显示进程。 AJAX(Asynchronous JavaScript and XML)不仅是一种缩写，更是用来描述JS中的任何一种异步操作。 2.2 XMLHttpRequest对象 JS的XMLHttpRequest用它来发起HTTP请求，XML是在发起这类请求时最常用的数据交换格式，XMLHttpRequest并不仅限于使用XML。而那些允许我们通过访问站点进行数据交流的基础是基于超文本传输协议(HTTP)的。 JavaScript中，使用这种协议来发送这类请求的代码就是XMLHttpRequest。JavaScript是一种面向对象的语言，而XMLHttpRequest就是一类对象。当使用new XmlHttpRequest()语法，并将其返回值赋值给一个变量时，它就具有了从某一地址请求资源的功能。 我们主要关注XMLHttpRequest中的以下这些可用的函数： open(method,url,async(可选),user(可选),password(可选)) send() onreadystatechange 可以在代码中给它赋值为一个函数 readyState 返回一个0~4的值，用来表示状态码 0 表示未发送 表示open()函数还没有执行 1 表示已发送 指open()函数已执行，但send()函数还没有执行。 2 表示接收到头部 表示send()函数已执行且头部和状态码status都可以获取了 3 表示解析中 表示头部已经收到，但响应体正在解析中 4 表示完成 表示请求完成，包括响应头和响应体的内容都已经接收到了。 status 返回HTTP状态码 responseText 当请求成功时，该属性会包含作为文本的响应体(如我们请求的JSON) 在JS中，一个重要原则：属性值可以是一个函数。因为JavaScript中的函数也是一类对象。对象是一类数据，因此它可以被赋值给一个变量（属性）、修改和传递。onreadystatechange的值应该是一个函数。 ▲▲▲▲▲▲▲▲▲▲一个重要的交互实例▲▲▲▲▲▲▲▲ //一个新的XMLHttpRequest对象 var myXMLHttpRequest = new XMLHttpRequest(); var url = \"http://\";//指向保存着JSON资源的URL myXMLHttpRequest.onreadystatechange = function() { if (myXMLHttpRequest.readyState === 4 && myXMLHttpRequest.status === 200) { var myObject = JSON.parse(myXMLHttpRequest.responseText); var myJSON = JSON.stringify(myObject); } } myXMLHttpRequest.open(\"GET\", url, true); myXMLHttpRequest.send(); 序列化：将对象转换成文本的过程 通过JSON.stringify()对JSON进行序列化 反序列化：将文本转换成对象的过程 使用javascript中的JSON.parse()进行反序列化操作，响应返回的JSON以文本的形式存储在responseText中。 当它被JSON.parse()解析后，就不再是JSON了，而是JavaScript对象。 var myJSON = JSON.parse(myXMLHttpRequest.responseText); //由于JSON一开始不是对象，使用JSON.parse()进行反序列化让JSON变成对象。 同源策略 出于安全考虑，浏览器对资源共享有一定的限制。同源策略就要求此类后台请求仅可以请求来自同一域名的资源。 由于后台请求仅可在浏览器的开发者工具中看见，因此保护了普通用户的安全。 2.3 混乱的关系与共享的原则 2.3.1 跨域资源共享(CORS) 通过AJAX向公共API发送请求而不受到同源策略的影响，这是因为在服务器上实现了==跨域资源共享==(CORS)。这些服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性。 //定义了证书是否可用。 Access-Control-Allow-Credentials:true //定义了哪些HTTP方法(GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT)是可用的。 Access-Control-Allow-Methods:GET, POST //允许哪些域名，这里*表示任意域名都是允许的。 Access-Control-Allow-Origin:* 银行防止黑客入侵 //使用CORS进行安全防护 Access-Control-Allow-Methods:POST Access-Control-Allow-Origin: http://www.bank.com 本例中仅允许通过POST方式请求资源. 同时设定了银行站点的URL，浏览器会禁止除了到\"http://www.bank.com\"以外的站点去获取资源. 2.3.2 JSON-P 作用：使用CORS也会遇到一些问题，而且也不是所有的JSON数据都是从标准的Web API获取的。比如你想要不同域名的多个站点共享一些JSON文件，你需要用到JSON-P. JSON-P是一种不是很规范的备选方案，通过\"padding(内联)\"——将JavaScript加入JSON文档，然后创建函数调用。 //JSON-P getTheAnimal( { \"animal\": \"cat\" } ); //在JS中声明的函数 function getTheAnimal(data) { var myAnimal = data.animal;//\"cat\" } //声明函数后利用标签不受同源策略影响，将标签动态添加到HTML文档的标签中 var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = \"http://xufuping.com/animal.json\"; document.getElementsByTagName('head')[0].appendChild(script); //服务端也需要对JSON-P提供一定的支持，它应该允许用户自定义函数的名字，它通常是作为URL中queryString的参数传递的 script.src = \"http://xufuping.com/animal.json?callback=getThing\"; //服务端会根据callback参数的值来动态地为在JSON中内联的函数命名。 getThing( { \"animal\": \"cat\" } ); JSON-P还需要服务端的不少支持，因为JSON资源必须包含JavaScript内联。不管是使用CORS还是JSON-P都离不开服务端的支持。因此，客户端跨域的XMLHttpRequest需要服务端的支持来保证JSON资源请求成功。 Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:20:10 "},"part3/json/3.html":{"url":"part3/json/3.html","title":"3.深入浅出、服务端扩展与 JSON 总结","keywords":"","body":"1. JSON 与客户端框架 框架是一层位于软件或编程语言之上的为开发者提供支持的结构。 1.1 jquery 和 JSON jquery 是一种开发者专注于操作 DOM 构建功能的抽象化工具。 1、jQuery.parseJSON('{ \"animal\": \"cat\"}') 相比较 JSON.parse()可以实现跨浏览器兼容。 2、JSON 交互更加简单粗暴 JS 创建一个 XMLHttpRequest 对象并从 haha API 获取 JSON //一个新的XMLHttpRequest对象 var myXMLHttpRequest = new XMLHttpRequest(); var url = \"http://api.haha.org/data\";//指向保存着JSON资源的URL myXMLHttpRequest.onreadystatechange = function() { if (myXMLHttpRequest.readyState === 4 && myXMLHttpRequest.status === 200) { var myObject = JSON.parse(myXMLHttpRequest.responseText); var myJSON = JSON.stringify(myObject); } } myXMLHttpRequest.open(\"GET\", url, true); myXMLHttpRequest.send(); jquery 并从 haha API 获取 JSON var url = \"http://api.haha.org/data\";//指向保存着JSON资源的URL $.getJSON(url, function(data) { // 对获取的数据进行一些操作 }); 1.2 AngularJS jQuery 框架是为 DOM 操作服务的抽象化工具，AngularJS 框架是专注于创建单页应用的抽象化工具。单页 Web 应用致力于为用户提供无缝交互的应用体验。（当用户仍在当前页面时，幕后的代码已经完成对资源的请求，用户从一个资源跳跃到另一个资源的操作将不再需要通过 URL 或是指向 URL 的链接来进行。） AngularJS 框架这种抽象工具为开发者节约了从零开始构建单页应用的时间，它所提供的，是一个基于模型-视图-控制器(MVC)架构概念得到框架。 模型 JavaScript对象即数据模型 视图 HTML（提供了与模型进行数据绑定的语法） 控制器 使用AngularJS语法来定义和操作与模型和视图间的交互的JavaScript文件。 在 AngularJS 数据模型中，把数据库中的数据放到数据模型中的最常见的方式就是使用 JSON，也就是通过 HTTP 协议来请求 JSON 数据，是一种客户端-服务端的关系，AngularJS 通过其核心服务$htpp 来使得通过这一协议进行的数据模型检索变得轻松。 使用 AngularJS 从 haha API 获取数据 angular.module('myApp', []) .controller('myAppController', function($scope, $http) { $http.get('http://api.haha.org/data') .success(function(data, status, headers, config) { $scope.weatherData = data; }); }); 绑定从 haha API 获取的天气数据的描述 {{ weatherData.weather[0].description }} // “ng-app”和“ng-controller”属性设置了一个支持数据绑定的视图，这是angularJS语法，详见angularJS 调用的是这段JSON数据： { \"coord\":{ …… }, \"sys\":{ …… }, \"weather\":[ { \"id\":800, \"main\":\"Clear\", \"description\":\"sky is clear\", \"icon\":\"02n\" } ], \"base\":\"stations\", \"main\":{ …… }, \"wind\":{ …… }, \"clouds\":{ …… }, \"dt\":1234564564, \"id\":18656456465, \"name\":\"Shuzenji\", \"cod\":200 } 2. JSON 与 NoSQL 2.1 CouchDB CouchDB 是一种使用 JSON 文档存储数据的 NoSQL 数据库，与平常的 SQL 并不同。 优点： 1. CouchDB使用文档来存储数据，当从数据库中查询一个账户时，得到的直接就是一个结构化的文档，没有必要进行重组，这样既高效又方便。 但是切记如果数据存储模型种类繁多需要的关系比较多那最好使用关系型模型数据库即SQL等。 // 使用JSON文档来表示账户 { \"firstName\": \"Bob\", \"lastName\": \"Barker\", \"age\": 91, \"addresses\":[ { \"city\": \"Somewhere\", \"state\": \"OR\", \"zip\": 97500 }, { \"city\": \"Some place\", \"state\": \"CA\", \"zip\": 96026 } ] } 2. 用CouchDB，当数据发生变化时就毋须修改表的结构了。 这里略微讲下：CouchDB API，有了 CouchDB 就可以通过 HTTP 请求资源的方式来获取数据库中的数据。 CouchDB: 它是一种面向文档得到 NoSQL 数据库 它存储和管理 JSON 文档 它会在存储与获取数据的同时维护好数据的结构 它使用基于 HTTP 的 API 来获取作为 JSON 文档资源的数据 它使用 JS 作为查询语言，且通过视图的 map 和 reduce 方法来跨 API 获取数据 3. 服务端的 JSON 技术按客户端和服务端的区别分类： 客户端：HTML、CSS、JavaScript 服务端：PHP、ASP.NET、Node.js、Ruby on Rails、Java、Go, 等等。 ==这一章是《JSON 必知必会-第九章》，主要讲述了序列化、反序列化与请求 JSON，通过 ASP.NET、PHP 论述；同时还讲述了发送 JSON HTTP 请求的其他方式包括 Ruby on Rails、Node.js、Java 等方式。==【本章涉及过多了解性的服务端内容，除了 node.js 简单叙述一下，其余内容略过】 3.1 Node.js 发送 HTTP Node.js 是服务端的 JavaScript，它基于谷歌开源 JavaScript 引擎 V8，通过 Node.js 就可以使用 JavaScript 编写服务端应用。 前面探讨过通过 JSON.parse()将 JSON 反序列化为 JavaScript 对象，因为 Node.js 也是 JS，所以方法相同。但是，在 Node.js 中不再使用 XMLHttpRequest 对象，在 Node.js 中通过更简单的 get()函数请求 JSON(以及其他类型的资源)。 // 本示例像API发送请求，并将得到的JSON反序列化为JS对象。 var http = require('http'); http.get({ host: 'api.haha.org', path: '/data/2.5/haha?q=Xushao,uk' }, function(response) { var body = ''; response.on('data', function(data) { body += data; }); response.on('end', function() { var hahaData = JSON.parse(body); console.log(hahaData.coord.lon); }); }); 4. JSON 总结 JSON 不仅仅是一种数据交换格式，还可以作为配置文件放在某一个地方。（比如将某个 INI、XML 格式文件修改为 JSON 文件，三者都有良好的可读性，并且都能迅速定位被修改完善。）【这里就不详细写例子了】 结语： 无论是作为服务器上的配置文件，还是作为通过 URL 请求的资源，JSON 始终都在履行作为数据交换格式的职责。 在服务端，对象可以被序列化为 JSON 格式的文本，并且通过反序列化变回对象。服务端代码可以请求 JSON（本笔记第三节有 ASP.NET 和 PHP 语言两种方式实现这一功能，没有详细叙述。） ▲JSXmlHttpRequest 可以通过 URL 请求 JSON 资源，为了在 JS 代码中使用 JSON，要先将它反序列化为 JSON 对象。JS 内置的 JSON.parse()函数能够快速有效地实现这一功能。 JSON 并不是唯一一种数据交换格式，有些数据以逗号分隔值(CSV)为载体，有些是 Excel 表格，还有些数据是 XML 格式，这种格式支持数据的嵌套。要记住，JSON 不总是最佳选择。在互联网浏览器这类通过 JS 来支持面向对象编程的系统中，JSON 是较为理想的数据交换格式。在那些面向对象的服务端 Web 框架之类的系统，JSON 依旧是较为理想的数据交换格式。 总之，选择格式前先考虑优缺点，用对的工具，去做对的工作。o(∩_∩)o Copyright © Zhang Peng.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2020-12-02 16:20:16 "}}